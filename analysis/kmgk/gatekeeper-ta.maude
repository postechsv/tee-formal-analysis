fmod GATEKEEPER-DATA is
  pr CRYPTO-KEY-SIZE .
  pr RETURN-CODE .
	pr FILE-ID .

  op GK-ENROLL : -> Nat [ctor] .
  eq GK-ENROLL = 0 .

  op GK-VERIFY : -> Nat [ctor] .
  eq GK-VERIFY = 1 .

  ops ERROR-NONE ERROR-INVALID ERROR-RETRY ERROR-UNKNOWN : -> Nat [ctor] .
  eq ERROR-NONE = 0 .
  eq ERROR-INVALID = 1 .
  eq ERROR-RETRY = 2 .
  eq ERROR-RETRY = 3 .

  op HANDLE-VERSION : -> Nat [ctor] .
  eq HANDLE-VERSION = 2 .

  op TEE-TRUE : -> ReturnCode [ctor] .
  eq TEE-TRUE = TEE-SUCCESS .

  op TEE-FALSE : -> Nat [ctor] .
  eq TEE-FALSE = 1 .

  op HMAC-SHA256-KEY-SIZE-BIT : -> CryptoKeySize [ctor] .
  eq HMAC-SHA256-KEY-SIZE-BIT = 256 Bits .

	op secretID : -> FileId [ctor] .
endfm

mod GATEKEEPER-TA-PROGRAM-DECL is
  pr TEE-IMP-STRUCT-DECL .
  pr GATEKEEPER-DATA .
  pr TEE-BEHAVIOR .
  pr TEE-IMP-BEHAVIOR .
  pr GATEKEEPER-PROGRAM-DECL .

  ops serializeResponse exit freeKey : -> Label [ctor] .
endm

mod GATEKEEPER-TA-PROGRAM is
  pr GATEKEEPER-TA-PROGRAM-DECL .

  op gatekeeperTA : -> Program [ctor] .

  eq gatekeeperTA = 
    struct {
    	var version ;
    	var userId ;
    	var flags ;
    
    	var salt ;
    	var signature ;
    
    	var hardwareBacked
    } PasswordHandleT ;
    
    struct {
    	var version ;
    	var challenge ;
    	var userId ;
    	var authenticatorId ;
    	var authenticatorType ;
    	var timestamp ;
    	var hmac
    } HwAuthTokenT ;

		TAGetMasterKey (masterKey)
    {
			return # TEE-SUCCESS
    }  ;

		TAComputePasswordSignature (signature, key, password, salt)
    {
    	return # noData
    }  ;

		TACreatePasswordHandle (passwordHandle, salt, userId, flags, handleVersion, password)
    {
    	struct PasswordHandleT pwHandle ;
    	var toSign ;
    
    	var masterKey ;
    	masterKey := # TEE-HANDLE-NULL ;
    	var res ;
    
    	AllocateTransientObject(# TEE-TYPE-HMAC-SHA256, # HMAC-SHA256-KEY-SIZE-BIT  ; res, masterKey) ;
    	if (!  (res === # TEE-SUCCESS)) {
    		goto exit
    	}  ;
    
    	pwHandle . version := handleVersion ;
    	pwHandle . salt := salt ;
    	pwHandle . userId := userId ;
    	pwHandle . flags := flags ;
    	pwHandle . hardwareBacked := # true ;
    
        toSign := pwHandle + password  ;
    
    	res := TAGetMasterKey(masterKey) ;
    	if (!  (res === # TEE-SUCCESS)) {
    		goto freeKey
    	}  ;
    
    	res := TAComputePasswordSignature(pwHandle . signature, masterKey, toSign, salt) ;
    	if (!  (res === # TEE-SUCCESS)) {
    		goto freeKey
    	}  ;
    
        passwordHandle := pwHandle ;
    
      freeKey :
    		FreeTransientObject(masterKey  ; masterKey) ;
      exit :
    		return res
    }  ;

    TADoVerify (expectedHandle, password)
    {
    	var res ;
    	struct PasswordHandleT passwordHandle ;
    
    
    	res := TACreatePasswordHandle(passwordHandle, expectedHandle . salt, expectedHandle . userId, expectedHandle . flags, expectedHandle . version, password) ;
    	if (!  (res === # TEE-SUCCESS)) {
    		goto exit
    	}  ;
    
    	
        if (passwordHandle . signature === expectedHandle . signature) {
    		res := # TEE-TRUE
    	} else {
    		res := # TEE-FALSE
    	}  ;
    
      exit :
    	return res
    }  ;

    TAMintAuthToken (authToken, timestamp, userId, authenticatorId, challenge)
    {
      return # true
    } ;

    TAVerify (uid, challenge, enrolledPasswordHandle, providedPassword, responseAuthToken)
    {
    	var res ;
    	res := # TEE-SUCCESS ;
    
    
    	var error ;
    	error := # ERROR-NONE ;
    	var timeout ;
    	timeout := # 0 ;
    	struct HwAuthTokenT authToken ;
    	var requestReenroll ;
    	requestReenroll := # false ;
    
    
    
    	struct PasswordHandleT passwordHandle ;
    	var userId ;
    	var authenticatorId ;
    	authenticatorId := # 0 ;
    
    	var timestamp ;
    	timestamp := # 0 ;
    	var throttle ;
    
    
    
    	passwordHandle := enrolledPasswordHandle ;
    
    	if (!  (passwordHandle . version <= # HANDLE-VERSION)) {
    		error := # ERROR-INVALID ;
    		goto serializeResponse
    	}  ;
    
    	userId := passwordHandle . userId ;
    
    
    	res := TADoVerify(passwordHandle, providedPassword) ;
    	if (res === # TEE-TRUE) {
    		var dummy ;
    		dummy := TAMintAuthToken(authToken, timestamp, userId, authenticatorId, challenge) ;
    		goto serializeResponse
    	} else {
    		if (res === # TEE-FALSE) {
    			if (!  (timeout <= # 0)) {
    				error := # ERROR-RETRY
    			} else {
    				error := # ERROR-INVALID
    			}  ;
    			goto serializeResponse
    		} else {
    			goto exit
    		} 
    	}  ;
    
      serializeResponse :
    	if (error === # ERROR-INVALID || error === # ERROR-UNKNOWN) {
    		skip
    	} else {
    		if (error === # ERROR-RETRY) {
        skip
    		} else {
    			if (error === # ERROR-NONE) {
        skip
    			} else { 
    				res := # TEE-ERROR-GENERIC
    			} 
    		} 
    	}  ;
    
      exit :
    	return res
    }  ;

    main (cmdId, uid, desiredPassword, currentPassword, cphVersion, cphUserId, cphFlags, cphSalt, cphSignature, cphHardwareBacked, responseHandle, challenge, ephVersion, ephUserId, ephFlags, ephSalt, ephSignature, ephHardwareBacked, providedPassword, responseAuthToken) {
      var ret ;
      if (cmdId === # GK-ENROLL) {
        struct PasswordHandleT currentPasswordHandle ;
        currentPasswordHandle . version := cphVersion ;
        currentPasswordHandle . userId := cphUserId ;
        currentPasswordHandle . flags := cphFlags ;
        currentPasswordHandle . salt := cphSalt ;
        currentPasswordHandle . signature := cphSignature ;
        currentPasswordHandle . hardwareBacked := cphHardwareBacked ;

        ret := # 405
        --- ret := TAEnroll(uid, desiredPassword, currentPassword, currentPasswordHandle, responseHandle)
      } else {
        if (cmdId === # GK-VERIFY) {
          struct PasswordHandleT enrolledPasswordHandle ;
          enrolledPasswordHandle . version := ephVersion ;
          enrolledPasswordHandle . userId := ephUserId ;
          enrolledPasswordHandle . flags := ephFlags ;
          enrolledPasswordHandle . salt := ephSalt ;
          enrolledPasswordHandle . signature := ephSignature ;
          enrolledPasswordHandle . hardwareBacked := ephHardwareBacked ;

          ret := TAVerify(uid, challenge, enrolledPasswordHandle, providedPassword, responseAuthToken)
        } else {
          ret := # 404
        }
      } ;

      return ret
    }
  .
endm