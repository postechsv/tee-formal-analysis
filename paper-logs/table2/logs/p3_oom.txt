		     \||||||||||||||||||/
		   --- Welcome to Maude ---
		     /||||||||||||||||||\
	    Maude 3.3.1 built: Apr 13 2023 16:10:31
	     Copyright 1997-2023 SRI International
		   Fri Jan  5 02:11:42 2024
op _`,_ left-identity collapse from AttributeSet to Attribute is unequal.
op __ left-identity collapse from [State] to State is unequal.
op __ left-identity collapse from NeList{Data} to Data is unequal.
op __ right-identity collapse from NeList{Data} to Data is unequal.
op __ left-identity collapse from [RaRequest?,List{RaRequest}] to RaRequest? is
    unequal.
op __ right-identity collapse from [RaRequest?,List{RaRequest}] to RaRequest?
    is unequal.
op __ left-identity collapse from [Set{TaObjectId},TaInstId?,List{ClientId},
    Oid] to Set{TaObjectId} is unequal.
op __ right-identity collapse from [Set{TaObjectId},TaInstId?,List{ClientId},
    Oid] to Set{TaObjectId} is unequal.
op _`,_ left-identity collapse from Map{Topic,List{ClientId}} to Entry{Topic,
    List{ClientId}} is unequal.
op __ left-identity collapse from NeList{MqttMsg} to MqttMsg is unequal.
op __ right-identity collapse from NeList{MqttMsg} to MqttMsg is unequal.
op _`,_ left-identity collapse from [Value?,ExpList,DeclList,K] to Value? is
    unequal.
op _`,_ right-identity collapse from [Value?,ExpList,DeclList,K] to Value? is
    unequal.
op __ left-identity collapse from NeList{SmcArgument} to SmcArgument is
    unequal.
op __ right-identity collapse from NeList{SmcArgument} to SmcArgument is
    unequal.
op _`,_ left-identity collapse from NeSet{TeeAttribute} to TeeAttribute is
    unequal.
op __ left-identity collapse from [List{CryptoKey},Set{CryptoKey}] to Set{
    CryptoKey} is unequal.
op __ right-identity collapse from [List{CryptoKey},Set{CryptoKey}] to Set{
    CryptoKey} is unequal.
op _`,_ left-identity collapse from NeSet{DataFlag} to DataFlag is unequal.
op _`,_ left-identity collapse from NeSet{ObjectUsage} to ObjectUsage is
    unequal.
op _`,_ left-identity collapse from [List{CryptoKey},Set{CryptoKey}] to List{
    CryptoKey} is unequal.
op _`,_ left-identity collapse from NeSet{TeeApiParam} to TeeApiParam is
    unequal.
op _`,_ left-identity collapse from Map{DataPosition,Data} to Entry{
    DataPosition,Data} is unequal.
op _`,_ left-identity collapse from NeSet{AttrId} to AttrId is unequal.
op _`,_ left-identity collapse from Map{SessionId,TaInstId} to Entry{SessionId,
    TaInstId} is unequal.
op _`,_ left-identity collapse from NeSet{FileId} to FileId is unequal.
op _`,_ left-identity collapse from Map{AppId,Set{FileId}} to Entry{AppId,Set{
    FileId}} is unequal.
op _`,_ left-identity collapse from Map{AppId,StorageStatus} to Entry{AppId,
    StorageStatus} is unequal.
op _`,_ left-identity collapse from Map{SessionId,List{SmcArgument}} to Entry{
    SessionId,List{SmcArgument}} is unequal.
op _`,_ left-identity collapse from [Set{TaObjectId},TaInstId?,List{ClientId},
    Oid] to TaInstId? is unequal.
op _`,_ left-identity collapse from Map{AppId,Set{TaObjectId}} to Entry{AppId,
    Set{TaObjectId}} is unequal.
op __ left-identity collapse from NeList{Service} to Service is unequal.
op __ right-identity collapse from NeList{Service} to Service is unequal.
op __ left-identity collapse from NeList{ServiceReturn} to ServiceReturn is
    unequal.
op __ right-identity collapse from NeList{ServiceReturn} to ServiceReturn is
    unequal.
op _~>_ left-identity collapse from [Value?,ExpList,DeclList,K] to Value? is
    unequal.
op _~>_ right-identity collapse from [Value?,ExpList,DeclList,K] to Value? is
    unequal.
op __ left-identity collapse from KConfig to KConfigItem is unequal.
op _;_ left-identity collapse from Map{Var,Nat} to Entry{Var,Nat} is unequal.
op _`,_ left-identity collapse from Map{Label,Stmt} to Entry{Label,Stmt} is
    unequal.
op _;_ left-identity collapse from Map{Nat,Value?} to Entry{Nat,Value?} is
    unequal.
op _;;_ left-identity collapse from [Value?,ExpList,DeclList,K] to Value? is
    unequal.
op _;;_ right-identity collapse from [Value?,ExpList,DeclList,K] to Value? is
    unequal.
op __ left-identity collapse from NeList{InvokeMessage} to InvokeMessage is
    unequal.
op __ right-identity collapse from NeList{InvokeMessage} to InvokeMessage is
    unequal.
op __ left-identity collapse from TransitionList to Transition is unequal.
op __ right-identity collapse from TransitionList to Transition is unequal.
==========================================
reduce in ANALYSIS : modelCheck(scenario(mqttzHost, mqttzTA, none), p3) .
ModelChecker: Property automaton has 6 states.
ModelCheckerSymbol: Examined 115 system states.
rewrites: 30383 in 60ms cpu (59ms real) (506383 rewrites/second)
result ModelCheckResult: counterexample({< mqttzBroker : MqttzBroker |
    execution-envs : ({< ra : RichApp | proc : none, prog : (struct{var algo ;
    var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : false,
    invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : data(0, pub(1)), data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : (data(0, pub(2)) data(1, pub(2))), data-counter : 2,
    max-data : 2, topic : BuildingTemperature, sending : false > < sub(1) :
    Subscriber | recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue
    : nil >,'send-msg} {pubMqttMsg(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, pub(1)) <
    mqttzBroker : MqttzBroker | execution-envs : ({< ra : RichApp | proc :
    none, prog : (struct{var algo ; var mode ; var keySize ; var opHandle ; var
    keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : true > < pub(2) : Publisher |
    collected-data : (data(0, pub(2)) data(1, pub(2))), data-counter : 2,
    max-data : 2, topic : BuildingTemperature, sending : false > < sub(1) :
    Subscriber | recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue
    : nil >,'recv-pub-msg} {recvPubMqttMsg(pub(1), ElectricityConsumption) <
    mqttzBroker : MqttzBroker | execution-envs : ({< ra : RichApp | proc :
    none, prog : (struct{var algo ; var mode ; var keySize ; var opHandle ; var
    keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)} {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : noRaReq, subscriber-list : (
    ElectricityConsumption |-> sub(1) sub(2), BuildingTemperature |-> sub(2)),
    wait-receiving : false > < pub(1) : Publisher | collected-data : nil,
    data-counter : 1, max-data : 1, topic : ElectricityConsumption, sending :
    true > < pub(2) : Publisher | collected-data : (data(0, pub(2)) data(1,
    pub(2))), data-counter : 2, max-data : 2, topic : BuildingTemperature,
    sending : false > < sub(1) : Subscriber | recv-msg-queue : nil > < sub(2) :
    Subscriber | recv-msg-queue : nil >,'send-msg-done} {< mqttzBroker :
    MqttzBroker | execution-envs : ({< ra : RichApp | proc : none, prog : (
    struct{var algo ; var mode ; var keySize ; var opHandle ; var
    keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)} {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : noRaReq, subscriber-list : (
    ElectricityConsumption |-> sub(1) sub(2), BuildingTemperature |-> sub(2)),
    wait-receiving : false > < pub(1) : Publisher | collected-data : nil,
    data-counter : 1, max-data : 1, topic : ElectricityConsumption, sending :
    false > < pub(2) : Publisher | collected-data : (data(0, pub(2)) data(1,
    pub(2))), data-counter : 2, max-data : 2, topic : BuildingTemperature,
    sending : false > < sub(1) : Subscriber | recv-msg-queue : nil > < sub(2) :
    Subscriber | recv-msg-queue : nil >,'send-ra-request} {< mqttzBroker :
    MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(1)) < ra
    : RichApp | proc : (k($in(# sessionId(0),# main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData) ~> $waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : (data(0, pub(2)) data(1, pub(2))), data-counter : 2,
    max-data : 2, topic : BuildingTemperature, sending : false > < sub(1) :
    Subscriber | recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue
    : nil >,'send-msg} {pubMqttMsg(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, pub(2)) <
    mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($in(# sessionId(
    0),# main,# 3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,#
    TEE-HANDLE-NULL,# fileName(pub(1)),# randomData,# encrypted(data(0, pub(
    1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))),# fileName(sub(1)),# anyData) ~> $waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : data(1, pub(2)), data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : true > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'recv-pub-msg} {recvPubMqttMsg(pub(2), BuildingTemperature) < mqttzBroker :
    MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(1)) < ra
    : RichApp | proc : (k($in(# sessionId(0),# main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData) ~> $waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(1)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : data(1, pub(2)), data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : true > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'send-msg-done} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($in(# sessionId(
    0),# main,# 3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,#
    TEE-HANDLE-NULL,# fileName(pub(1)),# randomData,# encrypted(data(0, pub(
    1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))),# fileName(sub(1)),# anyData) ~> $waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(1)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : data(1, pub(2)), data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'send-msg} {pubMqttMsg(msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, pub(2)) <
    mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($in(# sessionId(
    0),# main,# 3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,#
    TEE-HANDLE-NULL,# fileName(pub(1)),# randomData,# encrypted(data(0, pub(
    1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))),# fileName(sub(1)),# anyData) ~> $waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(1)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : true > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'recv-pub-msg} {recvPubMqttMsg(pub(2), BuildingTemperature) < mqttzBroker :
    MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(1)) < ra
    : RichApp | proc : (k($in(# sessionId(0),# main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData) ~> $waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : true > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'send-msg-done} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($in(# sessionId(
    0),# main,# 3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,#
    TEE-HANDLE-NULL,# fileName(pub(1)),# randomData,# encrypted(data(0, pub(
    1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))),# fileName(sub(1)),# anyData) ~> $waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'invoke-ta} {< mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : {sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'smc-request} {< mqttzBroker : MqttzBroker | execution-envs : ({smcRequest(
    requestor(ra) invokeMessage({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData})) waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(1)) < ra
    : RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'accept-smc-request} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{smcRequest(requestor(ra) invokeMessage({sessionId(0),main,# 3,# anyAlgo,#
    anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(
    1)),# randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData})) < ta : TrustApp | trust-app-id : REENCRYPT, app-status :
    normal, api-call : noCall, api-return : noReturn, current-api : noApi,
    api-state : noState, current-params : empty, id-counter : 0, proc : none,
    prog : (struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'accept-smc-request-subroutine} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(1)) < ra
    : RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) > invokeTA(ta, {sessionId(0),main,#
    3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,#
    fileName(pub(1)),# randomData,# encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))),# fileName(sub(1)),# anyData}, ra)}), pub-msg-queue
    : nil, ra-req-queue : ({msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)} {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(1)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'accept-invoke-ta} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra), task-counter : 0 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'handle-invoke-ta} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($in(#
    TEE-STORAGE-PRIVATE,# fileName(pub(1)),# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ)) ~> $waitSysCall(OpenPersistentObject) ~> $out(
    res,object) ~> if(! res === # TEE-SUCCESS){return res}else{skip} ;
    GetObjectInfo1(object ; res,objectInfo) ; if(! res === # TEE-SUCCESS){goto
    exit}else{skip} ; ReadObjectData(object,objectInfo . dataSize ; res,data) ;
    if(! res === # TEE-SUCCESS){goto exit}else{skip} ; exit : CloseObject(
    object ; object) ; return res) env((mRet |-> 0) ; (session |-> 12) ; (res
    |-> 31) ; (cliId |-> 7) ; (data |-> 20) ; (object |-> 22) ; (objectInfo |->
    23) ; (cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv
    |-> 8) ; (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (
    command |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4)
    ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |->
    undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> #
    anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7
    |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0,
    pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(1))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23 |-> struct((
    objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |-> 26) ; (
    objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra), task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'tee-api-call} {< mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(
    msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    apiCall(OpenPersistentObject, (fileId(fileName(pub(1))), flags((
    TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-SHARE-READ)))), api-return :
    noReturn, current-api : noApi, api-state : noState, current-params : empty,
    id-counter : 0, proc : (k($waitSysCall(OpenPersistentObject) ~> $out(res,
    object) ~> if(! res === # TEE-SUCCESS){return res}else{skip} ;
    GetObjectInfo1(object ; res,objectInfo) ; if(! res === # TEE-SUCCESS){goto
    exit}else{skip} ; ReadObjectData(object,objectInfo . dataSize ; res,data) ;
    if(! res === # TEE-SUCCESS){goto exit}else{skip} ; exit : CloseObject(
    object ; object) ; return res) env((mRet |-> 0) ; (session |-> 12) ; (res
    |-> 31) ; (cliId |-> 7) ; (data |-> 20) ; (object |-> 22) ; (objectInfo |->
    23) ; (cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv
    |-> 8) ; (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (
    command |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4)
    ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |->
    undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> #
    anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7
    |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0,
    pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(1))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23 |-> struct((
    objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |-> 26) ; (
    objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra), task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'tee-api-call-accept} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : OpenPersistentObject,
    api-state : waitStorageCheck, current-params : (fileId(fileName(pub(1))),
    flags((TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-SHARE-READ))), id-counter :
    0, proc : (k($waitSysCall(OpenPersistentObject) ~> $out(res,object) ~> if(!
    res === # TEE-SUCCESS){return res}else{skip} ; GetObjectInfo1(object ; res,
    objectInfo) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    ReadObjectData(object,objectInfo . dataSize ; res,data) ; if(! res === #
    TEE-SUCCESS){goto exit}else{skip} ; exit : CloseObject(object ; object) ;
    return res) env((mRet |-> 0) ; (session |-> 12) ; (res |-> 31) ; (cliId |->
    7) ; (data |-> 20) ; (object |-> 22) ; (objectInfo |-> 23) ; (cliKey |->
    20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |->
    undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> #
    anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7
    |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0,
    pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(1))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23 |-> struct((
    objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |-> 26) ; (
    objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra), task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) > reqTrustedOS(getStorageStatus
    checkFileExist(fileName(pub(1))), ta, REENCRYPT)}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'service-receive} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : normal, api-call :
    noCall, api-return : noReturn, current-api : OpenPersistentObject,
    api-state : waitStorageCheck, current-params : (fileId(fileName(pub(1))),
    flags((TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-SHARE-READ))), id-counter :
    0, proc : (k($waitSysCall(OpenPersistentObject) ~> $out(res,object) ~> if(!
    res === # TEE-SUCCESS){return res}else{skip} ; GetObjectInfo1(object ; res,
    objectInfo) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    ReadObjectData(object,objectInfo . dataSize ; res,data) ; if(! res === #
    TEE-SUCCESS){goto exit}else{skip} ; exit : CloseObject(object ; object) ;
    return res) env((mRet |-> 0) ; (session |-> 12) ; (res |-> 31) ; (cliId |->
    7) ; (data |-> 20) ; (object |-> 22) ; (objectInfo |-> 23) ; (cliKey |->
    20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |->
    undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> #
    anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7
    |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0,
    pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(1))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23 |-> struct((
    objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |-> 26) ; (
    objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra), task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'out-of-memory-threat} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : apiReturn(OpenPersistentObject,
    TEE-ERROR-OUT-OF-MEMORY, handle(TEE-HANDLE-NULL)), current-api :
    OpenPersistentObject, api-state : finished, current-params : (fileId(
    fileName(pub(1))), flags((TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ))), id-counter : 0, proc : (k($waitSysCall(
    OpenPersistentObject) ~> $out(res,object) ~> if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res) env((mRet |-> 0) ; (
    session |-> 12) ; (res |-> 31) ; (cliId |-> 7) ; (data |-> 20) ; (object
    |-> 22) ; (objectInfo |-> 23) ; (cliKey |-> 20) ; (oriCliKey |-> 20) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18) store((0 |-> undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3
    |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |->
    # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(
    1))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    anyAlgo) ; (14 |-> # anyMode) ; (15 |-> # anyKeySize) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |->
    undef) ; (20 |-> # randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23
    |-> struct((objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |->
    26) ; (objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra), task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'tee-api-call-return} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($in(#
    TEE-STORAGE-PRIVATE,# fileName(pub(1)),# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-ACCESS-WRITE, TEE-DATA-FLAG-ACCESS-WRITE-META,
    TEE-DATA-FLAG-OVERWRITE),# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(
    0),# handleId(0, ta)) ~> $waitSysCall(CreatePersistentObject) ~> $out(res,
    object) ~> if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0) env((mRet |-> 0) ; (
    session |-> 12) ; (res |-> 23) ; (cliId |-> 7) ; (object |-> 24) ; (cliKey
    |-> 20) ; (objDataFlag |-> 22) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (
    oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData
    |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (
    sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |->
    18) store((0 |-> undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> #
    anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> #
    TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(
    1))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    anyAlgo) ; (14 |-> # anyMode) ; (15 |-> # anyKeySize) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |->
    undef) ; (20 |-> # randomAttrVal) ; (21 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (
    22 |-> # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)) ; (23 |-> undef)
    ; (24 |-> # handleId(0, ta)) ; (25 |-> undef) ; (26 |-> undef) ; (27 |->
    undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> return # 0 ~> return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ;
    (res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(25) labels(empty)), prog : (
    struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra), task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'tee-api-call} {< mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(
    msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : apiCall(CreatePersistentObject, (handle(TEE-HANDLE-NULL), fileId(
    fileName(pub(1))), flags((TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-ACCESS-WRITE, TEE-DATA-FLAG-ACCESS-WRITE-META,
    TEE-DATA-FLAG-OVERWRITE)), opt(handleId(0, ta)), data(nil), size(dataSize(
    0)))), api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($waitSysCall(
    CreatePersistentObject) ~> $out(res,object) ~> if(! res === # TEE-SUCCESS){
    return # 1}else{skip} ; WriteObjectData(object,cliKey ; res) ; if(! res ===
    # TEE-SUCCESS){CloseAndDeletePersistentObject1(object ; res,object) ;
    return # 1}else{skip} ; CloseObject(object ; object) ; return # 0) env((
    mRet |-> 0) ; (session |-> 12) ; (res |-> 23) ; (cliId |-> 7) ; (object |->
    24) ; (cliKey |-> 20) ; (objDataFlag |-> 22) ; (oriCliKey |-> 20) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18) store((0 |-> undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3
    |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |->
    # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(
    1))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    anyAlgo) ; (14 |-> # anyMode) ; (15 |-> # anyKeySize) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |->
    undef) ; (20 |-> # randomAttrVal) ; (21 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (
    22 |-> # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)) ; (23 |-> undef)
    ; (24 |-> # handleId(0, ta)) ; (25 |-> undef) ; (26 |-> undef) ; (27 |->
    undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> return # 0 ~> return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ;
    (res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(25) labels(empty)), prog : (
    struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra), task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'tee-api-call-accept} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : apiReturn(CreatePersistentObject,
    TEE-ERROR-OUT-OF-MEMORY, handle(TEE-HANDLE-NULL)), current-api :
    CreatePersistentObject, api-state : finished, current-params : (handle(
    TEE-HANDLE-NULL), fileId(fileName(pub(1))), flags((
    TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)), opt(handleId(0,
    ta)), data(nil), size(dataSize(0))), id-counter : 0, proc : (k(
    $waitSysCall(CreatePersistentObject) ~> $out(res,object) ~> if(! res === #
    TEE-SUCCESS){return # 1}else{skip} ; WriteObjectData(object,cliKey ; res) ;
    if(! res === # TEE-SUCCESS){CloseAndDeletePersistentObject1(object ; res,
    object) ; return # 1}else{skip} ; CloseObject(object ; object) ; return #
    0) env((mRet |-> 0) ; (session |-> 12) ; (res |-> 23) ; (cliId |-> 7) ; (
    object |-> 24) ; (cliKey |-> 20) ; (objDataFlag |-> 22) ; (oriCliKey |->
    20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId
    |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (
    sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (
    sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> # 3) ; (2
    |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> #
    TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1))) ;
    (8 |-> # randomData) ; (9 |-> # encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(1))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (22 |-> # (
    TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)) ; (23 |-> undef)
    ; (24 |-> # handleId(0, ta)) ; (25 |-> undef) ; (26 |-> undef) ; (27 |->
    undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> return # 0 ~> return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ;
    (res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(25) labels(empty)), prog : (
    struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra), task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'tee-api-call-return} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($in(#
    TEE-ALG-AES-CBC-NOPAD,# TEE-MODE-DECRYPT,# 256 Bits) ~> $waitSysCall(
    AllocateOperation) ~> $out(res,sess . opHandle) ~> if(! res === #
    TEE-SUCCESS){sess . opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    if(! sess . keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess .
    keyHandle ; sess . keyHandle)}else{skip} ; AllocateTransientObject(#
    TEE-TYPE-AES,sess . keySize ; res,sess . keyHandle) ; if(! res === #
    TEE-SUCCESS){sess . keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    InitRefAttribute(# TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){goto err}else{skip} ; SetOperationKey(sess . opHandle,sess .
    keyHandle ; res) ; if(! res === # TEE-SUCCESS){goto err}else{skip} ; return
    res ; err : if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess
    . opHandle ; sess . opHandle)}else{skip} ; sess . opHandle := #
    TEE-HANDLE-NULL ; if(! sess . keyHandle === # TEE-HANDLE-NULL){
    FreeTransientObject(sess . keyHandle ; sess . keyHandle)}else{skip} ; sess
    . keyHandle := # TEE-HANDLE-NULL ; return res) env((mRet |-> 0) ; (mode |->
    21) ; (session |-> 12) ; (sess |-> 22) ; (attr |-> 28) ; (res |-> 29) ; (
    oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |->
    9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (
    sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle
    |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> #
    3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |->
    # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1)))
    ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(1))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # TEE-ALG-AES-CBC-NOPAD) ;
    (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> #
    0) ; (20 |-> # randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13)
    ; (mode |-> 14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17))
    ; (23 |-> undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (
    24 |-> # TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |->
    undef) ; (26 |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef)
    ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> # TEE-ERROR-OUT-OF-MEMORY)
    sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 19) ; (oriCliKey |-> 20) ;
    (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, exit |-> (return res), res :=[] ~> if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(30) labels(err |-> (if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res))), prog : (struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra), task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'tee-api-call} {< mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(
    msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : apiCall(AllocateOperation, (size(256 Bits), alg(TEE-ALG-AES-CBC-NOPAD),
    mode(TEE-MODE-DECRYPT))), api-return : noReturn, current-api : noApi,
    api-state : noState, current-params : empty, id-counter : 0, proc : (k(
    $waitSysCall(AllocateOperation) ~> $out(res,sess . opHandle) ~> if(! res
    === # TEE-SUCCESS){sess . opHandle := # TEE-HANDLE-NULL ; goto err}else{
    skip} ; if(! sess . keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(
    sess . keyHandle ; sess . keyHandle)}else{skip} ; AllocateTransientObject(#
    TEE-TYPE-AES,sess . keySize ; res,sess . keyHandle) ; if(! res === #
    TEE-SUCCESS){sess . keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    InitRefAttribute(# TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){goto err}else{skip} ; SetOperationKey(sess . opHandle,sess .
    keyHandle ; res) ; if(! res === # TEE-SUCCESS){goto err}else{skip} ; return
    res ; err : if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess
    . opHandle ; sess . opHandle)}else{skip} ; sess . opHandle := #
    TEE-HANDLE-NULL ; if(! sess . keyHandle === # TEE-HANDLE-NULL){
    FreeTransientObject(sess . keyHandle ; sess . keyHandle)}else{skip} ; sess
    . keyHandle := # TEE-HANDLE-NULL ; return res) env((mRet |-> 0) ; (mode |->
    21) ; (session |-> 12) ; (sess |-> 22) ; (attr |-> 28) ; (res |-> 29) ; (
    oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |->
    9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (
    sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle
    |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> #
    3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |->
    # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1)))
    ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(1))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # TEE-ALG-AES-CBC-NOPAD) ;
    (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> #
    0) ; (20 |-> # randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13)
    ; (mode |-> 14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17))
    ; (23 |-> undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (
    24 |-> # TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |->
    undef) ; (26 |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef)
    ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> # TEE-ERROR-OUT-OF-MEMORY)
    sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 19) ; (oriCliKey |-> 20) ;
    (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, exit |-> (return res), res :=[] ~> if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(30) labels(err |-> (if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res))), prog : (struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra), task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'tee-api-call-accept} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : apiReturn(AllocateOperation,
    TEE-ERROR-OUT-OF-MEMORY, empty), current-api : AllocateOperation, api-state
    : finished, current-params : (size(256 Bits), alg(TEE-ALG-AES-CBC-NOPAD),
    mode(TEE-MODE-DECRYPT)), id-counter : 0, proc : (k($waitSysCall(
    AllocateOperation) ~> $out(res,sess . opHandle) ~> if(! res === #
    TEE-SUCCESS){sess . opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    if(! sess . keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess .
    keyHandle ; sess . keyHandle)}else{skip} ; AllocateTransientObject(#
    TEE-TYPE-AES,sess . keySize ; res,sess . keyHandle) ; if(! res === #
    TEE-SUCCESS){sess . keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    InitRefAttribute(# TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){goto err}else{skip} ; SetOperationKey(sess . opHandle,sess .
    keyHandle ; res) ; if(! res === # TEE-SUCCESS){goto err}else{skip} ; return
    res ; err : if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess
    . opHandle ; sess . opHandle)}else{skip} ; sess . opHandle := #
    TEE-HANDLE-NULL ; if(! sess . keyHandle === # TEE-HANDLE-NULL){
    FreeTransientObject(sess . keyHandle ; sess . keyHandle)}else{skip} ; sess
    . keyHandle := # TEE-HANDLE-NULL ; return res) env((mRet |-> 0) ; (mode |->
    21) ; (session |-> 12) ; (sess |-> 22) ; (attr |-> 28) ; (res |-> 29) ; (
    oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |->
    9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (
    sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle
    |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> #
    3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |->
    # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1)))
    ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(1))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # TEE-ALG-AES-CBC-NOPAD) ;
    (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> #
    0) ; (20 |-> # randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13)
    ; (mode |-> 14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17))
    ; (23 |-> undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (
    24 |-> # TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |->
    undef) ; (26 |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef)
    ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> # TEE-ERROR-OUT-OF-MEMORY)
    sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 19) ; (oriCliKey |-> 20) ;
    (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, exit |-> (return res), res :=[] ~> if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(30) labels(err |-> (if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res))), prog : (struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra), task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'tee-api-call-return} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k(.K) env((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6)
    store((0 |-> # TEE-ERROR-GENERIC) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3
    |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |->
    # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(
    1))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    TEE-ALG-AES-CBC-NOPAD) ; (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits)
    ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> #
    TEE-ERROR-GENERIC) ; (19 |-> # TEE-ERROR-GENERIC) ; (20 |-> #
    randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13) ; (mode |->
    14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (23 |->
    undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (24 |-> #
    TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (26
    |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef) ; (29 |-> #
    TEE-ERROR-OUT-OF-MEMORY) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    nilStack) nextLoc(12) labels(empty)), prog : (struct{var objectType ; var
    objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra), task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'handle-invoke-ta-finish} {< mqttzBroker : MqttzBroker | execution-envs : (
    {waitReqRA(msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{invokeTAReturn({sessionId(0),main,# TEE-ERROR-GENERIC,# 3,# anyAlgo,# anyMode,
    # anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    1)),# anyData}, ra) < ta : TrustApp | trust-app-id : REENCRYPT, app-status
    : outOfMemory, api-call : noCall, api-return : noReturn, current-api :
    noApi, api-state : noState, current-params : empty, id-counter : 0, proc :
    none, prog : (struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'return-smc-request-subroutine} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(1)) < ra
    : RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{smcReturn(requestor(ra) invokeMessage({sessionId(0),main,# TEE-ERROR-GENERIC,#
    3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,#
    fileName(pub(1)),# randomData,# encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))),# fileName(sub(1)),# anyData})) < ta : TrustApp |
    trust-app-id : REENCRYPT, app-status : outOfMemory, api-call : noCall,
    api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'return-smc-request} {< mqttzBroker : MqttzBroker | execution-envs : ({
    smcReturn(requestor(ra) invokeMessage({sessionId(0),main,#
    TEE-ERROR-GENERIC,# 3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,#
    TEE-HANDLE-NULL,# fileName(pub(1)),# randomData,# encrypted(data(0, pub(
    1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))),# fileName(sub(1)),# anyData})) waitReqRA(msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'smc-return} {< mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(
    msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(1)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    1))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : {sessionId(0),main,#
    TEE-ERROR-GENERIC,# 3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,#
    TEE-HANDLE-NULL,# fileName(pub(1)),# randomData,# encrypted(data(0, pub(
    1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))),# fileName(sub(1)),# anyData} >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'invoke-ta-finish} {< mqttzBroker : MqttzBroker | execution-envs : ({retRA(
    msg anyData from ElectricityConsumption to sub(1), sub(1)) < ra : RichApp |
    proc : none, prog : (struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){
    var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData}),
    running : false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(1)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'ra-request-finish} {< mqttzBroker : MqttzBroker | execution-envs : ({< ra
    : RichApp | proc : none, prog : (struct{var algo ; var mode ; var keySize ;
    var opHandle ; var keyHandle}AesCipher ; main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData}),
    running : false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : {msg encrypted(data(0, pub(
    1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,msg anyData
    from ElectricityConsumption to sub(1),sub(1)}, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'send-sub-msg} {subMqttMsg(msg anyData from ElectricityConsumption to sub(
    1), sub(1)) < mqttzBroker : MqttzBroker | execution-envs : ({< ra : RichApp
    | proc : none, prog : (struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){
    var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData}),
    running : false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : {msg encrypted(data(0, pub(
    1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,msg anyData
    from ElectricityConsumption to sub(1),sub(1)}, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : true > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : nil > < sub(2) : Subscriber | recv-msg-queue : nil >,
    'recv-msg} {recvSubMqttMsg(sub(1), ElectricityConsumption) < mqttzBroker :
    MqttzBroker | execution-envs : ({< ra : RichApp | proc : none, prog : (
    struct{var algo ; var mode ; var keySize ; var opHandle ; var
    keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : {msg encrypted(data(0, pub(
    1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,msg anyData
    from ElectricityConsumption to sub(1),sub(1)}, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : true > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'send-sub-msg-done} {< mqttzBroker
    : MqttzBroker | execution-envs : ({< ra : RichApp | proc : none, prog : (
    struct{var algo ; var mode ; var keySize ; var opHandle ; var
    keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)} {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'send-ra-request} {< mqttzBroker :
    MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(2)) < ra
    : RichApp | proc : (k($in(# sessionId(0),# main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData) ~> $waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'invoke-ta} {< mqttzBroker :
    MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(2)) < ra
    : RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : {sessionId(0),main,# 3,# anyAlgo,# anyMode,# anyKeySize,#
    TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),# randomData,#
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(2)),#
    anyData}, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'smc-request} {< mqttzBroker :
    MqttzBroker | execution-envs : ({smcRequest(requestor(ra) invokeMessage({
    sessionId(0),main,# 3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,#
    TEE-HANDLE-NULL,# fileName(pub(1)),# randomData,# encrypted(data(0, pub(
    1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))),# fileName(sub(2)),# anyData})) waitReqRA(msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'accept-smc-request} {<
    mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{smcRequest(requestor(ra) invokeMessage({sessionId(0),main,# 3,# anyAlgo,#
    anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(
    1)),# randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData})) < ta : TrustApp | trust-app-id : REENCRYPT, app-status :
    outOfMemory, api-call : noCall, api-return : noReturn, current-api : noApi,
    api-state : noState, current-params : empty, id-counter : 0, proc : none,
    prog : (struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'accept-smc-request-subroutine} {<
    mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) > invokeTA(ta, {sessionId(0),main,#
    3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,#
    fileName(pub(1)),# randomData,# encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))),# fileName(sub(2)),# anyData}, ra)}), pub-msg-queue
    : nil, ra-req-queue : ({msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)} {msg
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}), ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,sub(2)}, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'accept-invoke-ta} {< mqttzBroker
    : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(2)) < ra
    : RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 1 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'handle-invoke-ta} {< mqttzBroker
    : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(2)) < ra
    : RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($in(#
    TEE-STORAGE-PRIVATE,# fileName(pub(1)),# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ)) ~> $waitSysCall(OpenPersistentObject) ~> $out(
    res,object) ~> if(! res === # TEE-SUCCESS){return res}else{skip} ;
    GetObjectInfo1(object ; res,objectInfo) ; if(! res === # TEE-SUCCESS){goto
    exit}else{skip} ; ReadObjectData(object,objectInfo . dataSize ; res,data) ;
    if(! res === # TEE-SUCCESS){goto exit}else{skip} ; exit : CloseObject(
    object ; object) ; return res) env((mRet |-> 0) ; (session |-> 12) ; (res
    |-> 31) ; (cliId |-> 7) ; (data |-> 20) ; (object |-> 22) ; (objectInfo |->
    23) ; (cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv
    |-> 8) ; (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (
    command |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4)
    ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |->
    undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> #
    anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7
    |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0,
    pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23 |-> struct((
    objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |-> 26) ; (
    objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'tee-api-call} {< mqttzBroker :
    MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(2)) < ra
    : RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : apiCall(OpenPersistentObject, (fileId(fileName(pub(1))), flags((
    TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-SHARE-READ)))), api-return :
    noReturn, current-api : noApi, api-state : noState, current-params : empty,
    id-counter : 0, proc : (k($waitSysCall(OpenPersistentObject) ~> $out(res,
    object) ~> if(! res === # TEE-SUCCESS){return res}else{skip} ;
    GetObjectInfo1(object ; res,objectInfo) ; if(! res === # TEE-SUCCESS){goto
    exit}else{skip} ; ReadObjectData(object,objectInfo . dataSize ; res,data) ;
    if(! res === # TEE-SUCCESS){goto exit}else{skip} ; exit : CloseObject(
    object ; object) ; return res) env((mRet |-> 0) ; (session |-> 12) ; (res
    |-> 31) ; (cliId |-> 7) ; (data |-> 20) ; (object |-> 22) ; (objectInfo |->
    23) ; (cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv
    |-> 8) ; (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (
    command |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4)
    ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |->
    undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> #
    anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7
    |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0,
    pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23 |-> struct((
    objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |-> 26) ; (
    objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'tee-api-call-accept} {<
    mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : apiReturn(OpenPersistentObject,
    TEE-ERROR-OUT-OF-MEMORY, handle(TEE-HANDLE-NULL)), current-api :
    OpenPersistentObject, api-state : finished, current-params : (fileId(
    fileName(pub(1))), flags((TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ))), id-counter : 0, proc : (k($waitSysCall(
    OpenPersistentObject) ~> $out(res,object) ~> if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res) env((mRet |-> 0) ; (
    session |-> 12) ; (res |-> 31) ; (cliId |-> 7) ; (data |-> 20) ; (object
    |-> 22) ; (objectInfo |-> 23) ; (cliKey |-> 20) ; (oriCliKey |-> 20) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18) store((0 |-> undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3
    |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |->
    # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(
    2))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    anyAlgo) ; (14 |-> # anyMode) ; (15 |-> # anyKeySize) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |->
    undef) ; (20 |-> # randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23
    |-> struct((objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |->
    26) ; (objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'tee-api-call-return} {<
    mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($in(#
    TEE-STORAGE-PRIVATE,# fileName(pub(1)),# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-ACCESS-WRITE, TEE-DATA-FLAG-ACCESS-WRITE-META,
    TEE-DATA-FLAG-OVERWRITE),# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(
    0),# handleId(0, ta)) ~> $waitSysCall(CreatePersistentObject) ~> $out(res,
    object) ~> if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0) env((mRet |-> 0) ; (
    session |-> 12) ; (res |-> 23) ; (cliId |-> 7) ; (object |-> 24) ; (cliKey
    |-> 20) ; (objDataFlag |-> 22) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (
    oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData
    |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (
    sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |->
    18) store((0 |-> undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> #
    anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> #
    TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(
    2))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    anyAlgo) ; (14 |-> # anyMode) ; (15 |-> # anyKeySize) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |->
    undef) ; (20 |-> # randomAttrVal) ; (21 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (
    22 |-> # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)) ; (23 |-> undef)
    ; (24 |-> # handleId(0, ta)) ; (25 |-> undef) ; (26 |-> undef) ; (27 |->
    undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> return # 0 ~> return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ;
    (res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(25) labels(empty)), prog : (
    struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'tee-api-call} {< mqttzBroker :
    MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(2)) < ra
    : RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : apiCall(CreatePersistentObject, (handle(TEE-HANDLE-NULL), fileId(
    fileName(pub(1))), flags((TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-ACCESS-WRITE, TEE-DATA-FLAG-ACCESS-WRITE-META,
    TEE-DATA-FLAG-OVERWRITE)), opt(handleId(0, ta)), data(nil), size(dataSize(
    0)))), api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($waitSysCall(
    CreatePersistentObject) ~> $out(res,object) ~> if(! res === # TEE-SUCCESS){
    return # 1}else{skip} ; WriteObjectData(object,cliKey ; res) ; if(! res ===
    # TEE-SUCCESS){CloseAndDeletePersistentObject1(object ; res,object) ;
    return # 1}else{skip} ; CloseObject(object ; object) ; return # 0) env((
    mRet |-> 0) ; (session |-> 12) ; (res |-> 23) ; (cliId |-> 7) ; (object |->
    24) ; (cliKey |-> 20) ; (objDataFlag |-> 22) ; (oriCliKey |-> 20) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18) store((0 |-> undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3
    |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |->
    # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(
    2))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    anyAlgo) ; (14 |-> # anyMode) ; (15 |-> # anyKeySize) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |->
    undef) ; (20 |-> # randomAttrVal) ; (21 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (
    22 |-> # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)) ; (23 |-> undef)
    ; (24 |-> # handleId(0, ta)) ; (25 |-> undef) ; (26 |-> undef) ; (27 |->
    undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> return # 0 ~> return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ;
    (res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(25) labels(empty)), prog : (
    struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'tee-api-call-accept} {<
    mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : apiReturn(CreatePersistentObject,
    TEE-ERROR-OUT-OF-MEMORY, handle(TEE-HANDLE-NULL)), current-api :
    CreatePersistentObject, api-state : finished, current-params : (handle(
    TEE-HANDLE-NULL), fileId(fileName(pub(1))), flags((
    TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)), opt(handleId(0,
    ta)), data(nil), size(dataSize(0))), id-counter : 0, proc : (k(
    $waitSysCall(CreatePersistentObject) ~> $out(res,object) ~> if(! res === #
    TEE-SUCCESS){return # 1}else{skip} ; WriteObjectData(object,cliKey ; res) ;
    if(! res === # TEE-SUCCESS){CloseAndDeletePersistentObject1(object ; res,
    object) ; return # 1}else{skip} ; CloseObject(object ; object) ; return #
    0) env((mRet |-> 0) ; (session |-> 12) ; (res |-> 23) ; (cliId |-> 7) ; (
    object |-> 24) ; (cliKey |-> 20) ; (objDataFlag |-> 22) ; (oriCliKey |->
    20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId
    |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (
    sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (
    sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> # 3) ; (2
    |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> #
    TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1))) ;
    (8 |-> # randomData) ; (9 |-> # encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (22 |-> # (
    TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)) ; (23 |-> undef)
    ; (24 |-> # handleId(0, ta)) ; (25 |-> undef) ; (26 |-> undef) ; (27 |->
    undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> return # 0 ~> return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ;
    (res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(25) labels(empty)), prog : (
    struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'tee-api-call-return} {<
    mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($in(#
    TEE-ALG-AES-CBC-NOPAD,# TEE-MODE-DECRYPT,# 256 Bits) ~> $waitSysCall(
    AllocateOperation) ~> $out(res,sess . opHandle) ~> if(! res === #
    TEE-SUCCESS){sess . opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    if(! sess . keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess .
    keyHandle ; sess . keyHandle)}else{skip} ; AllocateTransientObject(#
    TEE-TYPE-AES,sess . keySize ; res,sess . keyHandle) ; if(! res === #
    TEE-SUCCESS){sess . keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    InitRefAttribute(# TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){goto err}else{skip} ; SetOperationKey(sess . opHandle,sess .
    keyHandle ; res) ; if(! res === # TEE-SUCCESS){goto err}else{skip} ; return
    res ; err : if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess
    . opHandle ; sess . opHandle)}else{skip} ; sess . opHandle := #
    TEE-HANDLE-NULL ; if(! sess . keyHandle === # TEE-HANDLE-NULL){
    FreeTransientObject(sess . keyHandle ; sess . keyHandle)}else{skip} ; sess
    . keyHandle := # TEE-HANDLE-NULL ; return res) env((mRet |-> 0) ; (mode |->
    21) ; (session |-> 12) ; (sess |-> 22) ; (attr |-> 28) ; (res |-> 29) ; (
    oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |->
    9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (
    sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle
    |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> #
    3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |->
    # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1)))
    ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # TEE-ALG-AES-CBC-NOPAD) ;
    (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> #
    0) ; (20 |-> # randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13)
    ; (mode |-> 14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17))
    ; (23 |-> undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (
    24 |-> # TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |->
    undef) ; (26 |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef)
    ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> # TEE-ERROR-OUT-OF-MEMORY)
    sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 19) ; (oriCliKey |-> 20) ;
    (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, exit |-> (return res), res :=[] ~> if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(30) labels(err |-> (if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res))), prog : (struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'tee-api-call} {< mqttzBroker :
    MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(2)) < ra
    : RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : apiCall(AllocateOperation, (size(256 Bits), alg(TEE-ALG-AES-CBC-NOPAD),
    mode(TEE-MODE-DECRYPT))), api-return : noReturn, current-api : noApi,
    api-state : noState, current-params : empty, id-counter : 0, proc : (k(
    $waitSysCall(AllocateOperation) ~> $out(res,sess . opHandle) ~> if(! res
    === # TEE-SUCCESS){sess . opHandle := # TEE-HANDLE-NULL ; goto err}else{
    skip} ; if(! sess . keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(
    sess . keyHandle ; sess . keyHandle)}else{skip} ; AllocateTransientObject(#
    TEE-TYPE-AES,sess . keySize ; res,sess . keyHandle) ; if(! res === #
    TEE-SUCCESS){sess . keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    InitRefAttribute(# TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){goto err}else{skip} ; SetOperationKey(sess . opHandle,sess .
    keyHandle ; res) ; if(! res === # TEE-SUCCESS){goto err}else{skip} ; return
    res ; err : if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess
    . opHandle ; sess . opHandle)}else{skip} ; sess . opHandle := #
    TEE-HANDLE-NULL ; if(! sess . keyHandle === # TEE-HANDLE-NULL){
    FreeTransientObject(sess . keyHandle ; sess . keyHandle)}else{skip} ; sess
    . keyHandle := # TEE-HANDLE-NULL ; return res) env((mRet |-> 0) ; (mode |->
    21) ; (session |-> 12) ; (sess |-> 22) ; (attr |-> 28) ; (res |-> 29) ; (
    oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |->
    9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (
    sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle
    |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> #
    3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |->
    # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1)))
    ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # TEE-ALG-AES-CBC-NOPAD) ;
    (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> #
    0) ; (20 |-> # randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13)
    ; (mode |-> 14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17))
    ; (23 |-> undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (
    24 |-> # TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |->
    undef) ; (26 |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef)
    ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> # TEE-ERROR-OUT-OF-MEMORY)
    sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 19) ; (oriCliKey |-> 20) ;
    (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, exit |-> (return res), res :=[] ~> if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(30) labels(err |-> (if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res))), prog : (struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'tee-api-call-accept} {<
    mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : apiReturn(AllocateOperation,
    TEE-ERROR-OUT-OF-MEMORY, empty), current-api : AllocateOperation, api-state
    : finished, current-params : (size(256 Bits), alg(TEE-ALG-AES-CBC-NOPAD),
    mode(TEE-MODE-DECRYPT)), id-counter : 0, proc : (k($waitSysCall(
    AllocateOperation) ~> $out(res,sess . opHandle) ~> if(! res === #
    TEE-SUCCESS){sess . opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    if(! sess . keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess .
    keyHandle ; sess . keyHandle)}else{skip} ; AllocateTransientObject(#
    TEE-TYPE-AES,sess . keySize ; res,sess . keyHandle) ; if(! res === #
    TEE-SUCCESS){sess . keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    InitRefAttribute(# TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){goto err}else{skip} ; SetOperationKey(sess . opHandle,sess .
    keyHandle ; res) ; if(! res === # TEE-SUCCESS){goto err}else{skip} ; return
    res ; err : if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess
    . opHandle ; sess . opHandle)}else{skip} ; sess . opHandle := #
    TEE-HANDLE-NULL ; if(! sess . keyHandle === # TEE-HANDLE-NULL){
    FreeTransientObject(sess . keyHandle ; sess . keyHandle)}else{skip} ; sess
    . keyHandle := # TEE-HANDLE-NULL ; return res) env((mRet |-> 0) ; (mode |->
    21) ; (session |-> 12) ; (sess |-> 22) ; (attr |-> 28) ; (res |-> 29) ; (
    oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |->
    9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (
    sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle
    |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> #
    3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |->
    # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1)))
    ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # TEE-ALG-AES-CBC-NOPAD) ;
    (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> #
    0) ; (20 |-> # randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13)
    ; (mode |-> 14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17))
    ; (23 |-> undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (
    24 |-> # TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |->
    undef) ; (26 |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef)
    ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> # TEE-ERROR-OUT-OF-MEMORY)
    sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 19) ; (oriCliKey |-> 20) ;
    (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, exit |-> (return res), res :=[] ~> if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(30) labels(err |-> (if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res))), prog : (struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'tee-api-call-return} {<
    mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k(.K) env((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6)
    store((0 |-> # TEE-ERROR-GENERIC) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3
    |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |->
    # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(1))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (10 |-> # fileName(sub(
    2))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    TEE-ALG-AES-CBC-NOPAD) ; (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits)
    ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> #
    TEE-ERROR-GENERIC) ; (19 |-> # TEE-ERROR-GENERIC) ; (20 |-> #
    randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13) ; (mode |->
    14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (23 |->
    undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (24 |-> #
    TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (26
    |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef) ; (29 |-> #
    TEE-ERROR-OUT-OF-MEMORY) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    nilStack) nextLoc(12) labels(empty)), prog : (struct{var objectType ; var
    objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'handle-invoke-ta-finish} {<
    mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{invokeTAReturn({sessionId(0),main,# TEE-ERROR-GENERIC,# 3,# anyAlgo,# anyMode,
    # anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(1)),#
    randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData}, ra) < ta : TrustApp | trust-app-id : REENCRYPT, app-status
    : outOfMemory, api-call : noCall, api-return : noReturn, current-api :
    noApi, api-state : noState, current-params : empty, id-counter : 0, proc :
    none, prog : (struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'return-smc-request-subroutine} {<
    mqttzBroker : MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(1))) ; (2 |-> # encrypted(
    data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{smcReturn(requestor(ra) invokeMessage({sessionId(0),main,# TEE-ERROR-GENERIC,#
    3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,#
    fileName(pub(1)),# randomData,# encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))),# fileName(sub(2)),# anyData})) < ta : TrustApp |
    trust-app-id : REENCRYPT, app-status : outOfMemory, api-call : noCall,
    api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'return-smc-request} {<
    mqttzBroker : MqttzBroker | execution-envs : ({smcReturn(requestor(ra)
    invokeMessage({sessionId(0),main,# TEE-ERROR-GENERIC,# 3,# anyAlgo,#
    anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(
    1)),# randomData,# encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))),# fileName(sub(
    2)),# anyData})) waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(2)) < ra
    : RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'smc-return} {< mqttzBroker :
    MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption, sub(2)) < ra
    : RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(1))) ; (2 |-> # encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : {sessionId(0),main,# TEE-ERROR-GENERIC,# 3,#
    anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,#
    fileName(pub(1)),# randomData,# encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))),# fileName(sub(2)),# anyData} >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'invoke-ta-finish} {< mqttzBroker
    : MqttzBroker | execution-envs : ({retRA(msg anyData from
    ElectricityConsumption to sub(2), sub(2)) < ra : RichApp | proc : none,
    prog : (struct{var algo ; var mode ; var keySize ; var opHandle ; var
    keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(1)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(1))))) from pub(1) to ElectricityConsumption,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'ra-request-finish} {< mqttzBroker
    : MqttzBroker | execution-envs : ({< ra : RichApp | proc : none, prog : (
    struct{var algo ; var mode ; var keySize ; var opHandle ; var
    keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : {msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,msg anyData from ElectricityConsumption to sub(2),
    sub(2)}, cur-ra-req : noRaReq, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false
    > < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'send-sub-msg} {subMqttMsg(msg
    anyData from ElectricityConsumption to sub(2), sub(2)) < mqttzBroker :
    MqttzBroker | execution-envs : ({< ra : RichApp | proc : none, prog : (
    struct{var algo ; var mode ; var keySize ; var opHandle ; var
    keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : {msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,msg anyData from ElectricityConsumption to sub(2),
    sub(2)}, cur-ra-req : noRaReq, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : true >
    < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : nil >,'recv-msg} {recvSubMqttMsg(sub(2),
    ElectricityConsumption) < mqttzBroker : MqttzBroker | execution-envs : ({<
    ra : RichApp | proc : none, prog : (struct{var algo ; var mode ; var
    keySize ; var opHandle ; var keyHandle}AesCipher ; main(oriCliId,
    oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct
    AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : false,
    invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : {msg encrypted(data(0, pub(1)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(1))))) from pub(1) to
    ElectricityConsumption,msg anyData from ElectricityConsumption to sub(2),
    sub(2)}, cur-ra-req : noRaReq, subscriber-list : (ElectricityConsumption
    |-> sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : true >
    < pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data :
    1, topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'send-sub-msg-done} {< mqttzBroker : MqttzBroker |
    execution-envs : ({< ra : RichApp | proc : none, prog : (struct{var algo ;
    var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : false,
    invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : ({msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)} {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)}),
    ra-ret-queue : nil, cur-ra-req : noRaReq, subscriber-list : (
    ElectricityConsumption |-> sub(1) sub(2), BuildingTemperature |-> sub(2)),
    wait-receiving : false > < pub(1) : Publisher | collected-data : nil,
    data-counter : 1, max-data : 1, topic : ElectricityConsumption, sending :
    false > < pub(2) : Publisher | collected-data : nil, data-counter : 2,
    max-data : 2, topic : BuildingTemperature, sending : false > < sub(1) :
    Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption to
    sub(1) > < sub(2) : Subscriber | recv-msg-queue : msg anyData from
    ElectricityConsumption to sub(2) >,'send-ra-request} {< mqttzBroker :
    MqttzBroker | execution-envs : ({waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($in(# sessionId(0),# main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData) ~> $waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'invoke-ta} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : {sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'smc-request} {< mqttzBroker : MqttzBroker | execution-envs : (
    {smcRequest(requestor(ra) invokeMessage({sessionId(0),main,# 3,# anyAlgo,#
    anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(
    2)),# randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData})) waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'accept-smc-request} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{smcRequest(requestor(ra) invokeMessage({sessionId(0),main,# 3,# anyAlgo,#
    anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(
    2)),# randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData})) < ta : TrustApp | trust-app-id : REENCRYPT, app-status :
    outOfMemory, api-call : noCall, api-return : noReturn, current-api : noApi,
    api-state : noState, current-params : empty, id-counter : 0, proc : none,
    prog : (struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'accept-smc-request-subroutine} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) > invokeTA(ta, {sessionId(0),main,#
    3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,#
    fileName(pub(2)),# randomData,# encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))),# fileName(sub(2)),# anyData}, ra)}), pub-msg-queue
    : nil, ra-req-queue : {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'accept-invoke-ta} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 2 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'handle-invoke-ta} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($in(#
    TEE-STORAGE-PRIVATE,# fileName(pub(2)),# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ)) ~> $waitSysCall(OpenPersistentObject) ~> $out(
    res,object) ~> if(! res === # TEE-SUCCESS){return res}else{skip} ;
    GetObjectInfo1(object ; res,objectInfo) ; if(! res === # TEE-SUCCESS){goto
    exit}else{skip} ; ReadObjectData(object,objectInfo . dataSize ; res,data) ;
    if(! res === # TEE-SUCCESS){goto exit}else{skip} ; exit : CloseObject(
    object ; object) ; return res) env((mRet |-> 0) ; (session |-> 12) ; (res
    |-> 31) ; (cliId |-> 7) ; (data |-> 20) ; (object |-> 22) ; (objectInfo |->
    23) ; (cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv
    |-> 8) ; (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (
    command |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4)
    ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |->
    undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> #
    anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7
    |-> # fileName(pub(2))) ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23 |-> struct((
    objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |-> 26) ; (
    objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'tee-api-call} {< mqttzBroker : MqttzBroker | execution-envs :
    ({waitReqRA(msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : apiCall(OpenPersistentObject, (fileId(fileName(pub(2))), flags((
    TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-SHARE-READ)))), api-return :
    noReturn, current-api : noApi, api-state : noState, current-params : empty,
    id-counter : 0, proc : (k($waitSysCall(OpenPersistentObject) ~> $out(res,
    object) ~> if(! res === # TEE-SUCCESS){return res}else{skip} ;
    GetObjectInfo1(object ; res,objectInfo) ; if(! res === # TEE-SUCCESS){goto
    exit}else{skip} ; ReadObjectData(object,objectInfo . dataSize ; res,data) ;
    if(! res === # TEE-SUCCESS){goto exit}else{skip} ; exit : CloseObject(
    object ; object) ; return res) env((mRet |-> 0) ; (session |-> 12) ; (res
    |-> 31) ; (cliId |-> 7) ; (data |-> 20) ; (object |-> 22) ; (objectInfo |->
    23) ; (cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv
    |-> 8) ; (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (
    command |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4)
    ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |->
    undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> #
    anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7
    |-> # fileName(pub(2))) ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23 |-> struct((
    objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |-> 26) ; (
    objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'tee-api-call-accept} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : apiReturn(OpenPersistentObject,
    TEE-ERROR-OUT-OF-MEMORY, handle(TEE-HANDLE-NULL)), current-api :
    OpenPersistentObject, api-state : finished, current-params : (fileId(
    fileName(pub(2))), flags((TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ))), id-counter : 0, proc : (k($waitSysCall(
    OpenPersistentObject) ~> $out(res,object) ~> if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res) env((mRet |-> 0) ; (
    session |-> 12) ; (res |-> 31) ; (cliId |-> 7) ; (data |-> 20) ; (object
    |-> 22) ; (objectInfo |-> 23) ; (cliKey |-> 20) ; (oriCliKey |-> 20) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18) store((0 |-> undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3
    |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |->
    # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(
    2))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    anyAlgo) ; (14 |-> # anyMode) ; (15 |-> # anyKeySize) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |->
    undef) ; (20 |-> # randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23
    |-> struct((objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |->
    26) ; (objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'tee-api-call-return} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($in(#
    TEE-STORAGE-PRIVATE,# fileName(pub(2)),# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-ACCESS-WRITE, TEE-DATA-FLAG-ACCESS-WRITE-META,
    TEE-DATA-FLAG-OVERWRITE),# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(
    0),# handleId(0, ta)) ~> $waitSysCall(CreatePersistentObject) ~> $out(res,
    object) ~> if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0) env((mRet |-> 0) ; (
    session |-> 12) ; (res |-> 23) ; (cliId |-> 7) ; (object |-> 24) ; (cliKey
    |-> 20) ; (objDataFlag |-> 22) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (
    oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData
    |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (
    sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |->
    18) store((0 |-> undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> #
    anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> #
    TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(
    2))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    anyAlgo) ; (14 |-> # anyMode) ; (15 |-> # anyKeySize) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |->
    undef) ; (20 |-> # randomAttrVal) ; (21 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (
    22 |-> # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)) ; (23 |-> undef)
    ; (24 |-> # handleId(0, ta)) ; (25 |-> undef) ; (26 |-> undef) ; (27 |->
    undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> return # 0 ~> return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ;
    (res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(25) labels(empty)), prog : (
    struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'tee-api-call} {< mqttzBroker : MqttzBroker | execution-envs :
    ({waitReqRA(msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : apiCall(CreatePersistentObject, (handle(TEE-HANDLE-NULL), fileId(
    fileName(pub(2))), flags((TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-ACCESS-WRITE, TEE-DATA-FLAG-ACCESS-WRITE-META,
    TEE-DATA-FLAG-OVERWRITE)), opt(handleId(0, ta)), data(nil), size(dataSize(
    0)))), api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($waitSysCall(
    CreatePersistentObject) ~> $out(res,object) ~> if(! res === # TEE-SUCCESS){
    return # 1}else{skip} ; WriteObjectData(object,cliKey ; res) ; if(! res ===
    # TEE-SUCCESS){CloseAndDeletePersistentObject1(object ; res,object) ;
    return # 1}else{skip} ; CloseObject(object ; object) ; return # 0) env((
    mRet |-> 0) ; (session |-> 12) ; (res |-> 23) ; (cliId |-> 7) ; (object |->
    24) ; (cliKey |-> 20) ; (objDataFlag |-> 22) ; (oriCliKey |-> 20) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18) store((0 |-> undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3
    |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |->
    # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(
    2))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    anyAlgo) ; (14 |-> # anyMode) ; (15 |-> # anyKeySize) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |->
    undef) ; (20 |-> # randomAttrVal) ; (21 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (
    22 |-> # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)) ; (23 |-> undef)
    ; (24 |-> # handleId(0, ta)) ; (25 |-> undef) ; (26 |-> undef) ; (27 |->
    undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> return # 0 ~> return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ;
    (res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(25) labels(empty)), prog : (
    struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'tee-api-call-accept} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : apiReturn(CreatePersistentObject,
    TEE-ERROR-OUT-OF-MEMORY, handle(TEE-HANDLE-NULL)), current-api :
    CreatePersistentObject, api-state : finished, current-params : (handle(
    TEE-HANDLE-NULL), fileId(fileName(pub(2))), flags((
    TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)), opt(handleId(0,
    ta)), data(nil), size(dataSize(0))), id-counter : 0, proc : (k(
    $waitSysCall(CreatePersistentObject) ~> $out(res,object) ~> if(! res === #
    TEE-SUCCESS){return # 1}else{skip} ; WriteObjectData(object,cliKey ; res) ;
    if(! res === # TEE-SUCCESS){CloseAndDeletePersistentObject1(object ; res,
    object) ; return # 1}else{skip} ; CloseObject(object ; object) ; return #
    0) env((mRet |-> 0) ; (session |-> 12) ; (res |-> 23) ; (cliId |-> 7) ; (
    object |-> 24) ; (cliKey |-> 20) ; (objDataFlag |-> 22) ; (oriCliKey |->
    20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId
    |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (
    sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (
    sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> # 3) ; (2
    |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> #
    TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2))) ;
    (8 |-> # randomData) ; (9 |-> # encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (22 |-> # (
    TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)) ; (23 |-> undef)
    ; (24 |-> # handleId(0, ta)) ; (25 |-> undef) ; (26 |-> undef) ; (27 |->
    undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> return # 0 ~> return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ;
    (res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(25) labels(empty)), prog : (
    struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'tee-api-call-return} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($in(#
    TEE-ALG-AES-CBC-NOPAD,# TEE-MODE-DECRYPT,# 256 Bits) ~> $waitSysCall(
    AllocateOperation) ~> $out(res,sess . opHandle) ~> if(! res === #
    TEE-SUCCESS){sess . opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    if(! sess . keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess .
    keyHandle ; sess . keyHandle)}else{skip} ; AllocateTransientObject(#
    TEE-TYPE-AES,sess . keySize ; res,sess . keyHandle) ; if(! res === #
    TEE-SUCCESS){sess . keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    InitRefAttribute(# TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){goto err}else{skip} ; SetOperationKey(sess . opHandle,sess .
    keyHandle ; res) ; if(! res === # TEE-SUCCESS){goto err}else{skip} ; return
    res ; err : if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess
    . opHandle ; sess . opHandle)}else{skip} ; sess . opHandle := #
    TEE-HANDLE-NULL ; if(! sess . keyHandle === # TEE-HANDLE-NULL){
    FreeTransientObject(sess . keyHandle ; sess . keyHandle)}else{skip} ; sess
    . keyHandle := # TEE-HANDLE-NULL ; return res) env((mRet |-> 0) ; (mode |->
    21) ; (session |-> 12) ; (sess |-> 22) ; (attr |-> 28) ; (res |-> 29) ; (
    oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |->
    9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (
    sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle
    |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> #
    3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |->
    # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2)))
    ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # TEE-ALG-AES-CBC-NOPAD) ;
    (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> #
    0) ; (20 |-> # randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13)
    ; (mode |-> 14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17))
    ; (23 |-> undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (
    24 |-> # TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |->
    undef) ; (26 |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef)
    ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> # TEE-ERROR-OUT-OF-MEMORY)
    sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 19) ; (oriCliKey |-> 20) ;
    (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, exit |-> (return res), res :=[] ~> if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(30) labels(err |-> (if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res))), prog : (struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'tee-api-call} {< mqttzBroker : MqttzBroker | execution-envs :
    ({waitReqRA(msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : apiCall(AllocateOperation, (size(256 Bits), alg(TEE-ALG-AES-CBC-NOPAD),
    mode(TEE-MODE-DECRYPT))), api-return : noReturn, current-api : noApi,
    api-state : noState, current-params : empty, id-counter : 0, proc : (k(
    $waitSysCall(AllocateOperation) ~> $out(res,sess . opHandle) ~> if(! res
    === # TEE-SUCCESS){sess . opHandle := # TEE-HANDLE-NULL ; goto err}else{
    skip} ; if(! sess . keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(
    sess . keyHandle ; sess . keyHandle)}else{skip} ; AllocateTransientObject(#
    TEE-TYPE-AES,sess . keySize ; res,sess . keyHandle) ; if(! res === #
    TEE-SUCCESS){sess . keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    InitRefAttribute(# TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){goto err}else{skip} ; SetOperationKey(sess . opHandle,sess .
    keyHandle ; res) ; if(! res === # TEE-SUCCESS){goto err}else{skip} ; return
    res ; err : if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess
    . opHandle ; sess . opHandle)}else{skip} ; sess . opHandle := #
    TEE-HANDLE-NULL ; if(! sess . keyHandle === # TEE-HANDLE-NULL){
    FreeTransientObject(sess . keyHandle ; sess . keyHandle)}else{skip} ; sess
    . keyHandle := # TEE-HANDLE-NULL ; return res) env((mRet |-> 0) ; (mode |->
    21) ; (session |-> 12) ; (sess |-> 22) ; (attr |-> 28) ; (res |-> 29) ; (
    oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |->
    9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (
    sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle
    |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> #
    3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |->
    # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2)))
    ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # TEE-ALG-AES-CBC-NOPAD) ;
    (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> #
    0) ; (20 |-> # randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13)
    ; (mode |-> 14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17))
    ; (23 |-> undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (
    24 |-> # TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |->
    undef) ; (26 |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef)
    ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> # TEE-ERROR-OUT-OF-MEMORY)
    sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 19) ; (oriCliKey |-> 20) ;
    (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, exit |-> (return res), res :=[] ~> if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(30) labels(err |-> (if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res))), prog : (struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'tee-api-call-accept} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : apiReturn(AllocateOperation,
    TEE-ERROR-OUT-OF-MEMORY, empty), current-api : AllocateOperation, api-state
    : finished, current-params : (size(256 Bits), alg(TEE-ALG-AES-CBC-NOPAD),
    mode(TEE-MODE-DECRYPT)), id-counter : 0, proc : (k($waitSysCall(
    AllocateOperation) ~> $out(res,sess . opHandle) ~> if(! res === #
    TEE-SUCCESS){sess . opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    if(! sess . keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess .
    keyHandle ; sess . keyHandle)}else{skip} ; AllocateTransientObject(#
    TEE-TYPE-AES,sess . keySize ; res,sess . keyHandle) ; if(! res === #
    TEE-SUCCESS){sess . keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    InitRefAttribute(# TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){goto err}else{skip} ; SetOperationKey(sess . opHandle,sess .
    keyHandle ; res) ; if(! res === # TEE-SUCCESS){goto err}else{skip} ; return
    res ; err : if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess
    . opHandle ; sess . opHandle)}else{skip} ; sess . opHandle := #
    TEE-HANDLE-NULL ; if(! sess . keyHandle === # TEE-HANDLE-NULL){
    FreeTransientObject(sess . keyHandle ; sess . keyHandle)}else{skip} ; sess
    . keyHandle := # TEE-HANDLE-NULL ; return res) env((mRet |-> 0) ; (mode |->
    21) ; (session |-> 12) ; (sess |-> 22) ; (attr |-> 28) ; (res |-> 29) ; (
    oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |->
    9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (
    sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle
    |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> #
    3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |->
    # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2)))
    ; (8 |-> # randomData) ; (9 |-> # encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # TEE-ALG-AES-CBC-NOPAD) ;
    (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> #
    0) ; (20 |-> # randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13)
    ; (mode |-> 14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17))
    ; (23 |-> undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (
    24 |-> # TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |->
    undef) ; (26 |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef)
    ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> # TEE-ERROR-OUT-OF-MEMORY)
    sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 19) ; (oriCliKey |-> 20) ;
    (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, exit |-> (return res), res :=[] ~> if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(30) labels(err |-> (if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res))), prog : (struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'tee-api-call-return} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k(.K) env((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6)
    store((0 |-> # TEE-ERROR-GENERIC) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3
    |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |->
    # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(
    2))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    TEE-ALG-AES-CBC-NOPAD) ; (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits)
    ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> #
    TEE-ERROR-GENERIC) ; (19 |-> # TEE-ERROR-GENERIC) ; (20 |-> #
    randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13) ; (mode |->
    14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (23 |->
    undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (24 |-> #
    TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (26
    |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef) ; (29 |-> #
    TEE-ERROR-OUT-OF-MEMORY) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    nilStack) nextLoc(12) labels(empty)), prog : (struct{var objectType ; var
    objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'handle-invoke-ta-finish} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{invokeTAReturn({sessionId(0),main,# TEE-ERROR-GENERIC,# 3,# anyAlgo,# anyMode,
    # anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra) < ta : TrustApp | trust-app-id : REENCRYPT, app-status
    : outOfMemory, api-call : noCall, api-return : noReturn, current-api :
    noApi, api-state : noState, current-params : empty, id-counter : 0, proc :
    none, prog : (struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'return-smc-request-subroutine} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{smcReturn(requestor(ra) invokeMessage({sessionId(0),main,# TEE-ERROR-GENERIC,#
    3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,#
    fileName(pub(2)),# randomData,# encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))),# fileName(sub(2)),# anyData})) < ta : TrustApp |
    trust-app-id : REENCRYPT, app-status : outOfMemory, api-call : noCall,
    api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'return-smc-request} {< mqttzBroker : MqttzBroker |
    execution-envs : ({smcReturn(requestor(ra) invokeMessage({sessionId(0),
    main,# TEE-ERROR-GENERIC,# 3,# anyAlgo,# anyMode,# anyKeySize,#
    TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),# randomData,#
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(2)),#
    anyData})) waitReqRA(msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD,
    key(teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2)
    to BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'smc-return} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : {sessionId(0),main,#
    TEE-ERROR-GENERIC,# 3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,#
    TEE-HANDLE-NULL,# fileName(pub(2)),# randomData,# encrypted(data(0, pub(
    2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))),# fileName(sub(2)),# anyData} >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'invoke-ta-finish} {< mqttzBroker : MqttzBroker |
    execution-envs : ({retRA(msg anyData from BuildingTemperature to sub(2),
    sub(2)) < ra : RichApp | proc : none, prog : (struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; main(oriCliId,
    oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct
    AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : false,
    invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : {msg
    encrypted(data(0, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'ra-request-finish} {< mqttzBroker : MqttzBroker |
    execution-envs : ({< ra : RichApp | proc : none, prog : (struct{var algo ;
    var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : false,
    invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,msg anyData from
    BuildingTemperature to sub(2),sub(2)}, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'send-sub-msg} {subMqttMsg(msg anyData from BuildingTemperature
    to sub(2), sub(2)) < mqttzBroker : MqttzBroker | execution-envs : ({< ra :
    RichApp | proc : none, prog : (struct{var algo ; var mode ; var keySize ;
    var opHandle ; var keyHandle}AesCipher ; main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData}),
    running : false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,msg anyData from
    BuildingTemperature to sub(2),sub(2)}, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : true > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : msg anyData from ElectricityConsumption
    to sub(2) >,'recv-msg} {recvSubMqttMsg(sub(2), BuildingTemperature) <
    mqttzBroker : MqttzBroker | execution-envs : ({< ra : RichApp | proc :
    none, prog : (struct{var algo ; var mode ; var keySize ; var opHandle ; var
    keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : {msg encrypted(data(0, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,msg anyData from
    BuildingTemperature to sub(2),sub(2)}, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : true > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'send-sub-msg-done} {< mqttzBroker : MqttzBroker |
    execution-envs : ({< ra : RichApp | proc : none, prog : (struct{var algo ;
    var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : false,
    invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : {msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, ra-ret-queue : nil, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'send-ra-request} {< mqttzBroker : MqttzBroker | execution-envs
    : ({waitReqRA(msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($in(# sessionId(0),
    # main,# 3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,#
    TEE-HANDLE-NULL,# fileName(pub(2)),# randomData,# encrypted(data(1, pub(
    2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))),# fileName(sub(2)),# anyData) ~> $waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'invoke-ta} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : {sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'smc-request} {< mqttzBroker : MqttzBroker | execution-envs : ({
    smcRequest(requestor(ra) invokeMessage({sessionId(0),main,# 3,# anyAlgo,#
    anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(
    2)),# randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData})) waitReqRA(msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'accept-smc-request} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{smcRequest(requestor(ra) invokeMessage({sessionId(0),main,# 3,# anyAlgo,#
    anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(
    2)),# randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData})) < ta : TrustApp | trust-app-id : REENCRYPT, app-status :
    outOfMemory, api-call : noCall, api-return : noReturn, current-api : noApi,
    api-state : noState, current-params : empty, id-counter : 0, proc : none,
    prog : (struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'accept-smc-request-subroutine} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) > invokeTA(ta, {sessionId(0),main,#
    3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,#
    fileName(pub(2)),# randomData,# encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))),# fileName(sub(2)),# anyData}, ra)}), pub-msg-queue
    : nil, ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(
    data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature,sub(2)}, subscriber-list : (ElectricityConsumption |->
    sub(1) sub(2), BuildingTemperature |-> sub(2)), wait-receiving : false > <
    pub(1) : Publisher | collected-data : nil, data-counter : 1, max-data : 1,
    topic : ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'accept-invoke-ta} {< mqttzBroker : MqttzBroker | execution-envs
    : ({waitReqRA(msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 3 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'handle-invoke-ta} {< mqttzBroker : MqttzBroker | execution-envs
    : ({waitReqRA(msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($in(#
    TEE-STORAGE-PRIVATE,# fileName(pub(2)),# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ)) ~> $waitSysCall(OpenPersistentObject) ~> $out(
    res,object) ~> if(! res === # TEE-SUCCESS){return res}else{skip} ;
    GetObjectInfo1(object ; res,objectInfo) ; if(! res === # TEE-SUCCESS){goto
    exit}else{skip} ; ReadObjectData(object,objectInfo . dataSize ; res,data) ;
    if(! res === # TEE-SUCCESS){goto exit}else{skip} ; exit : CloseObject(
    object ; object) ; return res) env((mRet |-> 0) ; (session |-> 12) ; (res
    |-> 31) ; (cliId |-> 7) ; (data |-> 20) ; (object |-> 22) ; (objectInfo |->
    23) ; (cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv
    |-> 8) ; (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (
    command |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4)
    ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |->
    undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> #
    anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7
    |-> # fileName(pub(2))) ; (8 |-> # randomData) ; (9 |-> # encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23 |-> struct((
    objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |-> 26) ; (
    objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'tee-api-call} {< mqttzBroker : MqttzBroker | execution-envs : (
    {waitReqRA(msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : apiCall(OpenPersistentObject, (fileId(fileName(pub(2))), flags((
    TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-SHARE-READ)))), api-return :
    noReturn, current-api : noApi, api-state : noState, current-params : empty,
    id-counter : 0, proc : (k($waitSysCall(OpenPersistentObject) ~> $out(res,
    object) ~> if(! res === # TEE-SUCCESS){return res}else{skip} ;
    GetObjectInfo1(object ; res,objectInfo) ; if(! res === # TEE-SUCCESS){goto
    exit}else{skip} ; ReadObjectData(object,objectInfo . dataSize ; res,data) ;
    if(! res === # TEE-SUCCESS){goto exit}else{skip} ; exit : CloseObject(
    object ; object) ; return res) env((mRet |-> 0) ; (session |-> 12) ; (res
    |-> 31) ; (cliId |-> 7) ; (data |-> 20) ; (object |-> 22) ; (objectInfo |->
    23) ; (cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv
    |-> 8) ; (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (
    command |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4)
    ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |->
    undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> #
    anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7
    |-> # fileName(pub(2))) ; (8 |-> # randomData) ; (9 |-> # encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23 |-> struct((
    objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |-> 26) ; (
    objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'tee-api-call-accept} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : apiReturn(OpenPersistentObject,
    TEE-ERROR-OUT-OF-MEMORY, handle(TEE-HANDLE-NULL)), current-api :
    OpenPersistentObject, api-state : finished, current-params : (fileId(
    fileName(pub(2))), flags((TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ))), id-counter : 0, proc : (k($waitSysCall(
    OpenPersistentObject) ~> $out(res,object) ~> if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res) env((mRet |-> 0) ; (
    session |-> 12) ; (res |-> 31) ; (cliId |-> 7) ; (data |-> 20) ; (object
    |-> 22) ; (objectInfo |-> 23) ; (cliKey |-> 20) ; (oriCliKey |-> 20) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18) store((0 |-> undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3
    |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |->
    # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(
    2))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    anyAlgo) ; (14 |-> # anyMode) ; (15 |-> # anyKeySize) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |->
    undef) ; (20 |-> # randomAttrVal) ; (21 |-> undef) ; (22 |-> undef) ; (23
    |-> struct((objectType |-> 24) ; (objectSize |-> 25) ; (maxObjectSize |->
    26) ; (objectUsage |-> 27) ; (dataSize |-> 28) ; (dataPosition |-> 29) ;
    handleFlags |-> 30)) ; (24 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (
    27 |-> undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |->
    undef) sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> if(! res === # TEE-SUCCESS){res := saveKey(cliId,cliKey) ; return #
    0}else{skip} ; return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ; (
    res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(32) labels(exit |-> (
    CloseObject(object ; object) ; return res))), prog : (struct{var objectType
    ; var objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'tee-api-call-return} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($in(#
    TEE-STORAGE-PRIVATE,# fileName(pub(2)),# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-ACCESS-WRITE, TEE-DATA-FLAG-ACCESS-WRITE-META,
    TEE-DATA-FLAG-OVERWRITE),# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(
    0),# handleId(0, ta)) ~> $waitSysCall(CreatePersistentObject) ~> $out(res,
    object) ~> if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0) env((mRet |-> 0) ; (
    session |-> 12) ; (res |-> 23) ; (cliId |-> 7) ; (object |-> 24) ; (cliKey
    |-> 20) ; (objDataFlag |-> 22) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (
    oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData
    |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (
    sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |->
    18) store((0 |-> undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3 |-> #
    anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |-> #
    TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(
    2))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    anyAlgo) ; (14 |-> # anyMode) ; (15 |-> # anyKeySize) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |->
    undef) ; (20 |-> # randomAttrVal) ; (21 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (
    22 |-> # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)) ; (23 |-> undef)
    ; (24 |-> # handleId(0, ta)) ; (25 |-> undef) ; (26 |-> undef) ; (27 |->
    undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> return # 0 ~> return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ;
    (res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(25) labels(empty)), prog : (
    struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'tee-api-call} {< mqttzBroker : MqttzBroker | execution-envs : (
    {waitReqRA(msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : apiCall(CreatePersistentObject, (handle(TEE-HANDLE-NULL), fileId(
    fileName(pub(2))), flags((TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-ACCESS-WRITE, TEE-DATA-FLAG-ACCESS-WRITE-META,
    TEE-DATA-FLAG-OVERWRITE)), opt(handleId(0, ta)), data(nil), size(dataSize(
    0)))), api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($waitSysCall(
    CreatePersistentObject) ~> $out(res,object) ~> if(! res === # TEE-SUCCESS){
    return # 1}else{skip} ; WriteObjectData(object,cliKey ; res) ; if(! res ===
    # TEE-SUCCESS){CloseAndDeletePersistentObject1(object ; res,object) ;
    return # 1}else{skip} ; CloseObject(object ; object) ; return # 0) env((
    mRet |-> 0) ; (session |-> 12) ; (res |-> 23) ; (cliId |-> 7) ; (object |->
    24) ; (cliKey |-> 20) ; (objDataFlag |-> 22) ; (oriCliKey |-> 20) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18) store((0 |-> undef) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3
    |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |->
    # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(
    2))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    anyAlgo) ; (14 |-> # anyMode) ; (15 |-> # anyKeySize) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |->
    undef) ; (20 |-> # randomAttrVal) ; (21 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (
    22 |-> # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)) ; (23 |-> undef)
    ; (24 |-> # handleId(0, ta)) ; (25 |-> undef) ; (26 |-> undef) ; (27 |->
    undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> return # 0 ~> return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ;
    (res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(25) labels(empty)), prog : (
    struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'tee-api-call-accept} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : apiReturn(CreatePersistentObject,
    TEE-ERROR-OUT-OF-MEMORY, handle(TEE-HANDLE-NULL)), current-api :
    CreatePersistentObject, api-state : finished, current-params : (handle(
    TEE-HANDLE-NULL), fileId(fileName(pub(2))), flags((
    TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)), opt(handleId(0,
    ta)), data(nil), size(dataSize(0))), id-counter : 0, proc : (k(
    $waitSysCall(CreatePersistentObject) ~> $out(res,object) ~> if(! res === #
    TEE-SUCCESS){return # 1}else{skip} ; WriteObjectData(object,cliKey ; res) ;
    if(! res === # TEE-SUCCESS){CloseAndDeletePersistentObject1(object ; res,
    object) ; return # 1}else{skip} ; CloseObject(object ; object) ; return #
    0) env((mRet |-> 0) ; (session |-> 12) ; (res |-> 23) ; (cliId |-> 7) ; (
    object |-> 24) ; (cliKey |-> 20) ; (objDataFlag |-> 22) ; (oriCliKey |->
    20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId
    |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (
    sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (
    sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> # 3) ; (2
    |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> #
    TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2))) ;
    (8 |-> # randomData) ; (9 |-> # encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # anyAlgo) ; (14 |-> #
    anyMode) ; (15 |-> # anyKeySize) ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> #
    TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> undef) ; (20 |-> #
    randomAttrVal) ; (21 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (22 |-> # (
    TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE)) ; (23 |-> undef)
    ; (24 |-> # handleId(0, ta)) ; (25 |-> undef) ; (26 |-> undef) ; (27 |->
    undef) ; (28 |-> undef) ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 21) ; (cliId |-> 7) ; (
    cliKey |-> 20) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ;
    (oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, empty, res :=[]
    ~> return # 0 ~> return # 0, 22) :: item((mRet |-> 0) ; (session |-> 12) ;
    (res |-> 19) ; (oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (
    oriCliData |-> 9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command
    |-> 1) ; (sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (
    sessOpHandle |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18, exit |-> (return
    res), res :=[] ~> if(! res === # 0){res := # TEE-ERROR-OUT-OF-MEMORY ; goto
    exit}else{skip} ; res := allocResources(session,# 0) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(25) labels(empty)), prog : (
    struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'tee-api-call-return} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k($in(#
    TEE-ALG-AES-CBC-NOPAD,# TEE-MODE-DECRYPT,# 256 Bits) ~> $waitSysCall(
    AllocateOperation) ~> $out(res,sess . opHandle) ~> if(! res === #
    TEE-SUCCESS){sess . opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    if(! sess . keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess .
    keyHandle ; sess . keyHandle)}else{skip} ; AllocateTransientObject(#
    TEE-TYPE-AES,sess . keySize ; res,sess . keyHandle) ; if(! res === #
    TEE-SUCCESS){sess . keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    InitRefAttribute(# TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){goto err}else{skip} ; SetOperationKey(sess . opHandle,sess .
    keyHandle ; res) ; if(! res === # TEE-SUCCESS){goto err}else{skip} ; return
    res ; err : if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess
    . opHandle ; sess . opHandle)}else{skip} ; sess . opHandle := #
    TEE-HANDLE-NULL ; if(! sess . keyHandle === # TEE-HANDLE-NULL){
    FreeTransientObject(sess . keyHandle ; sess . keyHandle)}else{skip} ; sess
    . keyHandle := # TEE-HANDLE-NULL ; return res) env((mRet |-> 0) ; (mode |->
    21) ; (session |-> 12) ; (sess |-> 22) ; (attr |-> 28) ; (res |-> 29) ; (
    oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |->
    9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (
    sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle
    |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> #
    3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |->
    # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2)))
    ; (8 |-> # randomData) ; (9 |-> # encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # TEE-ALG-AES-CBC-NOPAD) ;
    (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> #
    0) ; (20 |-> # randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13)
    ; (mode |-> 14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17))
    ; (23 |-> undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (
    24 |-> # TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |->
    undef) ; (26 |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef)
    ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> # TEE-ERROR-OUT-OF-MEMORY)
    sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 19) ; (oriCliKey |-> 20) ;
    (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, exit |-> (return res), res :=[] ~> if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(30) labels(err |-> (if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res))), prog : (struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'tee-api-call} {< mqttzBroker : MqttzBroker | execution-envs : (
    {waitReqRA(msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : apiCall(AllocateOperation, (size(256 Bits), alg(TEE-ALG-AES-CBC-NOPAD),
    mode(TEE-MODE-DECRYPT))), api-return : noReturn, current-api : noApi,
    api-state : noState, current-params : empty, id-counter : 0, proc : (k(
    $waitSysCall(AllocateOperation) ~> $out(res,sess . opHandle) ~> if(! res
    === # TEE-SUCCESS){sess . opHandle := # TEE-HANDLE-NULL ; goto err}else{
    skip} ; if(! sess . keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(
    sess . keyHandle ; sess . keyHandle)}else{skip} ; AllocateTransientObject(#
    TEE-TYPE-AES,sess . keySize ; res,sess . keyHandle) ; if(! res === #
    TEE-SUCCESS){sess . keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    InitRefAttribute(# TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){goto err}else{skip} ; SetOperationKey(sess . opHandle,sess .
    keyHandle ; res) ; if(! res === # TEE-SUCCESS){goto err}else{skip} ; return
    res ; err : if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess
    . opHandle ; sess . opHandle)}else{skip} ; sess . opHandle := #
    TEE-HANDLE-NULL ; if(! sess . keyHandle === # TEE-HANDLE-NULL){
    FreeTransientObject(sess . keyHandle ; sess . keyHandle)}else{skip} ; sess
    . keyHandle := # TEE-HANDLE-NULL ; return res) env((mRet |-> 0) ; (mode |->
    21) ; (session |-> 12) ; (sess |-> 22) ; (attr |-> 28) ; (res |-> 29) ; (
    oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |->
    9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (
    sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle
    |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> #
    3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |->
    # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2)))
    ; (8 |-> # randomData) ; (9 |-> # encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # TEE-ALG-AES-CBC-NOPAD) ;
    (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> #
    0) ; (20 |-> # randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13)
    ; (mode |-> 14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17))
    ; (23 |-> undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (
    24 |-> # TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |->
    undef) ; (26 |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef)
    ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> # TEE-ERROR-OUT-OF-MEMORY)
    sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 19) ; (oriCliKey |-> 20) ;
    (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, exit |-> (return res), res :=[] ~> if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(30) labels(err |-> (if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res))), prog : (struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'tee-api-call-accept} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : apiReturn(AllocateOperation,
    TEE-ERROR-OUT-OF-MEMORY, empty), current-api : AllocateOperation, api-state
    : finished, current-params : (size(256 Bits), alg(TEE-ALG-AES-CBC-NOPAD),
    mode(TEE-MODE-DECRYPT)), id-counter : 0, proc : (k($waitSysCall(
    AllocateOperation) ~> $out(res,sess . opHandle) ~> if(! res === #
    TEE-SUCCESS){sess . opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    if(! sess . keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess .
    keyHandle ; sess . keyHandle)}else{skip} ; AllocateTransientObject(#
    TEE-TYPE-AES,sess . keySize ; res,sess . keyHandle) ; if(! res === #
    TEE-SUCCESS){sess . keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ;
    InitRefAttribute(# TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){goto err}else{skip} ; SetOperationKey(sess . opHandle,sess .
    keyHandle ; res) ; if(! res === # TEE-SUCCESS){goto err}else{skip} ; return
    res ; err : if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess
    . opHandle ; sess . opHandle)}else{skip} ; sess . opHandle := #
    TEE-HANDLE-NULL ; if(! sess . keyHandle === # TEE-HANDLE-NULL){
    FreeTransientObject(sess . keyHandle ; sess . keyHandle)}else{skip} ; sess
    . keyHandle := # TEE-HANDLE-NULL ; return res) env((mRet |-> 0) ; (mode |->
    21) ; (session |-> 12) ; (sess |-> 22) ; (attr |-> 28) ; (res |-> 29) ; (
    oriCliKey |-> 20) ; (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |->
    9) ; (destCliId |-> 10) ; (destCliData |-> 11) ; (command |-> 1) ; (
    sessAlgo |-> 2) ; (sessMode |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle
    |-> 5) ; (sessKeyHandle |-> 6) ; ret |-> 18) store((0 |-> undef) ; (1 |-> #
    3) ; (2 |-> # anyAlgo) ; (3 |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |->
    # TEE-HANDLE-NULL) ; (6 |-> # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2)))
    ; (8 |-> # randomData) ; (9 |-> # encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(2))) ; (11 |-> # anyData)
    ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ; (keySize |-> 15) ; (
    opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> # TEE-ALG-AES-CBC-NOPAD) ;
    (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits) ; (16 |-> #
    TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> undef) ; (19 |-> #
    0) ; (20 |-> # randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13)
    ; (mode |-> 14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17))
    ; (23 |-> undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (
    24 |-> # TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |->
    undef) ; (26 |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef)
    ; (29 |-> undef) ; (30 |-> undef) ; 31 |-> # TEE-ERROR-OUT-OF-MEMORY)
    sdecl(struct{var objectType ; var objectSize ; var maxObjectSize ; var
    objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    item((mRet |-> 0) ; (session |-> 12) ; (res |-> 19) ; (oriCliKey |-> 20) ;
    (oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, exit |-> (return res), res :=[] ~> if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesKey(session,oriCliKey) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesIv(session,
    oriCliIv) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; var decData ; decData := # (nil).List{Data} ; res :=
    cipherBuffer(session,oriCliData,decData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; var destCliIv ; destCliIv
    := # dummyIv ; var destCliKey ; destCliKey := # randomAttrVal ; res :=
    getKey(destCliId,destCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 1) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,destCliKey) ; if(! res ===
    # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,destCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := cipherBuffer(session,
    decData,destCliData) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto exit
    ; exit : return res, 21) :: item((mRet |-> 0) ; (session |-> 12) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; (sessKeyHandle |-> 6)
    ; ret |-> 18, empty, ret :=[] ~> return ret, 19) :: item((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6,
    empty, mRet :=[], 12) :: nilStack) nextLoc(30) labels(err |-> (if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res))), prog : (struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'tee-api-call-return} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : (k(.K) env((mRet |-> 0) ; (
    oriCliId |-> 7) ; (oriCliIv |-> 8) ; (oriCliData |-> 9) ; (destCliId |->
    10) ; (destCliData |-> 11) ; (command |-> 1) ; (sessAlgo |-> 2) ; (sessMode
    |-> 3) ; (sessKeySize |-> 4) ; (sessOpHandle |-> 5) ; sessKeyHandle |-> 6)
    store((0 |-> # TEE-ERROR-GENERIC) ; (1 |-> # 3) ; (2 |-> # anyAlgo) ; (3
    |-> # anyMode) ; (4 |-> # anyKeySize) ; (5 |-> # TEE-HANDLE-NULL) ; (6 |->
    # TEE-HANDLE-NULL) ; (7 |-> # fileName(pub(2))) ; (8 |-> # randomData) ; (9
    |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (10 |-> # fileName(sub(
    2))) ; (11 |-> # anyData) ; (12 |-> struct((algo |-> 13) ; (mode |-> 14) ;
    (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (13 |-> #
    TEE-ALG-AES-CBC-NOPAD) ; (14 |-> # TEE-MODE-DECRYPT) ; (15 |-> # 256 Bits)
    ; (16 |-> # TEE-HANDLE-NULL) ; (17 |-> # TEE-HANDLE-NULL) ; (18 |-> #
    TEE-ERROR-GENERIC) ; (19 |-> # TEE-ERROR-GENERIC) ; (20 |-> #
    randomAttrVal) ; (21 |-> # 0) ; (22 |-> struct((algo |-> 13) ; (mode |->
    14) ; (keySize |-> 15) ; (opHandle |-> 16) ; keyHandle |-> 17)) ; (23 |->
    undef) ; (23 |-> # TEE-ERROR-OUT-OF-MEMORY) ; (24 |-> undef) ; (24 |-> #
    TEE-HANDLE-NULL) ; (25 |-> undef) ; (25 |-> undef) ; (26 |-> undef) ; (26
    |-> undef) ; (27 |-> undef) ; (27 |-> undef) ; (28 |-> undef) ; (29 |-> #
    TEE-ERROR-OUT-OF-MEMORY) ; (30 |-> undef) ; 31 |-> #
    TEE-ERROR-OUT-OF-MEMORY) sdecl(struct{var objectType ; var objectSize ; var
    maxObjectSize ; var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ;; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher) fdecl(allocResources(session,mode){
    struct AesCipher sess ; var attr ; var res ; sess := session ; sess . algo
    := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === #
    1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ;; setAesKey(session,key){struct AesCipher sess ; var attr ;
    var res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ;; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ;; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ;; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ;; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ;; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ;; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}) fstack(
    nilStack) nextLoc(12) labels(empty)), prog : (struct{var objectType ; var
    objectSize ; var maxObjectSize ; var objectUsage ; var dataSize ; var
    dataPosition ; var handleFlags}TeeObjectInfo ; struct{var algo ; var mode ;
    var keySize ; var opHandle ; var keyHandle}AesCipher ; allocResources(
    session,mode){struct AesCipher sess ; var attr ; var res ; sess := session
    ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ;
    if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){
    sess . mode := # TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}}
    ; if(! sess . opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle
    ; sess . opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,
    sess . keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : true, task : task({sessionId(0),main,# 3,# anyAlgo,# anyMode,#
    anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra), task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'handle-invoke-ta-finish} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{invokeTAReturn({sessionId(0),main,# TEE-ERROR-GENERIC,# 3,# anyAlgo,# anyMode,
    # anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),#
    randomData,# encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(
    2)),# anyData}, ra) < ta : TrustApp | trust-app-id : REENCRYPT, app-status
    : outOfMemory, api-call : noCall, api-return : noReturn, current-api :
    noApi, api-state : noState, current-params : empty, id-counter : 0, proc :
    none, prog : (struct{var objectType ; var objectSize ; var maxObjectSize ;
    var objectUsage ; var dataSize ; var dataPosition ; var
    handleFlags}TeeObjectInfo ; struct{var algo ; var mode ; var keySize ; var
    opHandle ; var keyHandle}AesCipher ; allocResources(session,mode){struct
    AesCipher sess ; var attr ; var res ; sess := session ; sess . algo := #
    TEE-ALG-AES-CBC-NOPAD ; sess . keySize := # 256 Bits ; if(mode === # 1){
    sess . mode := # TEE-MODE-ENCRYPT}else{if(mode === # 0){sess . mode := #
    TEE-MODE-DECRYPT}else{return # TEE-ERROR-BAD-PARAMETERS}} ; if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; AllocateOperation(sess . algo,sess . mode,sess .
    keySize ; res,sess . opHandle) ; if(! res === # TEE-SUCCESS){sess .
    opHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle
    === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'return-smc-request-subroutine} {< mqttzBroker : MqttzBroker |
    execution-envs : ({waitReqRA(msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature, sub(2)) < ra :
    RichApp | proc : (k($waitSysCall(TeecInvokeCommand) ~> $out(ret | sess,#
    main,cmd,sessionContext . algo,sessionContext . mode,sessionContext .
    keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData) ~> return destCliData) env((mRet
    |-> 0) ; (cmd |-> 13) ; (sess |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12)
    ; (oriCliData |-> 2) ; (destCliId |-> 3) ; (destCliData |-> 14) ; (
    sessionContext |-> 6) ; ret |-> 4) store((0 |-> undef) ; (1 |-> # fileName(
    pub(2))) ; (2 |-> # encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> #
    fileName(sub(2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct(
    (algo |-> 7) ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ;
    keyHandle |-> 11)) ; (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> #
    anyKeySize) ; (10 |-> # TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12
    |-> # randomData) ; (13 |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo
    ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher) fdecl(
    main(oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := #
    sessionId(0) ; struct AesCipher sessionContext ; sessionContext . algo := #
    anyAlgo ; sessionContext . mode := # anyMode ; sessionContext . keySize :=
    # anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}) fstack(item((mRet |-> 0) ; (
    oriCliId |-> 1) ; (oriCliData |-> 2) ; destCliId |-> 3, empty, mRet :=[],
    4) :: nilStack) nextLoc(15) labels(empty)), prog : (struct{var algo ; var
    mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : true, invoke-req-queue
    : nil, invoke-ret-queue : nil >} |
{smcReturn(requestor(ra) invokeMessage({sessionId(0),main,# TEE-ERROR-GENERIC,#
    3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,# TEE-HANDLE-NULL,#
    fileName(pub(2)),# randomData,# encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))),# fileName(sub(2)),# anyData})) < ta : TrustApp |
    trust-app-id : REENCRYPT, app-status : outOfMemory, api-call : noCall,
    api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'return-smc-request} {< mqttzBroker : MqttzBroker |
    execution-envs : ({smcReturn(requestor(ra) invokeMessage({sessionId(0),
    main,# TEE-ERROR-GENERIC,# 3,# anyAlgo,# anyMode,# anyKeySize,#
    TEE-HANDLE-NULL,# TEE-HANDLE-NULL,# fileName(pub(2)),# randomData,#
    encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))),# fileName(sub(2)),#
    anyData})) waitReqRA(msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD,
    key(teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2)
    to BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'smc-return} {< mqttzBroker : MqttzBroker | execution-envs : ({
    waitReqRA(msg encrypted(data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(
    teeAttribute(TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2))))) from pub(2) to
    BuildingTemperature, sub(2)) < ra : RichApp | proc : (k($waitSysCall(
    TeecInvokeCommand) ~> $out(ret | sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData) ~> return destCliData) env((mRet |-> 0) ; (cmd |-> 13) ; (sess
    |-> 5) ; (oriCliId |-> 1) ; (oriCliIv |-> 12) ; (oriCliData |-> 2) ; (
    destCliId |-> 3) ; (destCliData |-> 14) ; (sessionContext |-> 6) ; ret |->
    4) store((0 |-> undef) ; (1 |-> # fileName(pub(2))) ; (2 |-> # encrypted(
    data(1, pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(
    TEE-ATTR-SECRET-VALUE, keyAttrValue(pub(2)))))) ; (3 |-> # fileName(sub(
    2))) ; (4 |-> undef) ; (5 |-> # sessionId(0)) ; (6 |-> struct((algo |-> 7)
    ; (mode |-> 8) ; (keySize |-> 9) ; (opHandle |-> 10) ; keyHandle |-> 11)) ;
    (7 |-> # anyAlgo) ; (8 |-> # anyMode) ; (9 |-> # anyKeySize) ; (10 |-> #
    TEE-HANDLE-NULL) ; (11 |-> # TEE-HANDLE-NULL) ; (12 |-> # randomData) ; (13
    |-> # 3) ; 14 |-> # anyData) sdecl(struct{var algo ; var mode ; var keySize
    ; var opHandle ; var keyHandle}AesCipher) fdecl(main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData})
    fstack(item((mRet |-> 0) ; (oriCliId |-> 1) ; (oriCliData |-> 2) ;
    destCliId |-> 3, empty, mRet :=[], 4) :: nilStack) nextLoc(15) labels(
    empty)), prog : (struct{var algo ; var mode ; var keySize ; var opHandle ;
    var keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    true, invoke-req-queue : nil, invoke-ret-queue : {sessionId(0),main,#
    TEE-ERROR-GENERIC,# 3,# anyAlgo,# anyMode,# anyKeySize,# TEE-HANDLE-NULL,#
    TEE-HANDLE-NULL,# fileName(pub(2)),# randomData,# encrypted(data(1, pub(
    2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))),# fileName(sub(2)),# anyData} >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'invoke-ta-finish} {< mqttzBroker : MqttzBroker | execution-envs
    : ({retRA(msg anyData from BuildingTemperature to sub(2), sub(2)) < ra :
    RichApp | proc : none, prog : (struct{var algo ; var mode ; var keySize ;
    var opHandle ; var keyHandle}AesCipher ; main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData}),
    running : false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : {msg encrypted(data(1,
    pub(2)), TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,sub(2)},
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'ra-request-finish} {< mqttzBroker : MqttzBroker |
    execution-envs : ({< ra : RichApp | proc : none, prog : (struct{var algo ;
    var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ; main(
    oriCliId,oriCliData,destCliId){var ret ; var sess ; sess := # sessionId(0)
    ; struct AesCipher sessionContext ; sessionContext . algo := # anyAlgo ;
    sessionContext . mode := # anyMode ; sessionContext . keySize := #
    anyKeySize ; sessionContext . opHandle := # TEE-HANDLE-NULL ;
    sessionContext . keyHandle := # TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv
    := # randomData ; var cmd ; cmd := # 3 ; var destCliData ; destCliData := #
    anyData ; TeecInvokeCommand(sess,# main,cmd,sessionContext . algo,
    sessionContext . mode,sessionContext . keySize,sessionContext . opHandle,
    sessionContext . keyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData ; ret) ; return destCliData}), running : false,
    invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,msg anyData from
    BuildingTemperature to sub(2),sub(2)}, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'send-sub-msg} {subMqttMsg(msg anyData from BuildingTemperature
    to sub(2), sub(2)) < mqttzBroker : MqttzBroker | execution-envs : ({< ra :
    RichApp | proc : none, prog : (struct{var algo ; var mode ; var keySize ;
    var opHandle ; var keyHandle}AesCipher ; main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData}),
    running : false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,msg anyData from
    BuildingTemperature to sub(2),sub(2)}, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : true > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2))) >,'recv-msg} {recvSubMqttMsg(sub(2), BuildingTemperature) <
    mqttzBroker : MqttzBroker | execution-envs : ({< ra : RichApp | proc :
    none, prog : (struct{var algo ; var mode ; var keySize ; var opHandle ; var
    keyHandle}AesCipher ; main(oriCliId,oriCliData,destCliId){var ret ; var
    sess ; sess := # sessionId(0) ; struct AesCipher sessionContext ;
    sessionContext . algo := # anyAlgo ; sessionContext . mode := # anyMode ;
    sessionContext . keySize := # anyKeySize ; sessionContext . opHandle := #
    TEE-HANDLE-NULL ; sessionContext . keyHandle := # TEE-HANDLE-NULL ; var
    oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd := # 3 ; var
    destCliData ; destCliData := # anyData ; TeecInvokeCommand(sess,# main,cmd,
    sessionContext . algo,sessionContext . mode,sessionContext . keySize,
    sessionContext . opHandle,sessionContext . keyHandle,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData ; ret) ; return destCliData}), running :
    false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : {msg encrypted(data(1, pub(2)),
    TEE-ALG-AES-CBC-NOPAD, key(teeAttribute(TEE-ATTR-SECRET-VALUE,
    keyAttrValue(pub(2))))) from pub(2) to BuildingTemperature,msg anyData from
    BuildingTemperature to sub(2),sub(2)}, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : true > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2)) (msg anyData from BuildingTemperature to sub(2))) >,
    'send-sub-msg-done} {< mqttzBroker : MqttzBroker | execution-envs : ({< ra
    : RichApp | proc : none, prog : (struct{var algo ; var mode ; var keySize ;
    var opHandle ; var keyHandle}AesCipher ; main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData}),
    running : false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    (getStorageStatus checkFileExist(fileName(pub(1)))), service-out : nil,
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2)) (msg anyData from BuildingTemperature to sub(2))) >,
    'get-storage-status} {< mqttzBroker : MqttzBroker | execution-envs : ({< ra
    : RichApp | proc : none, prog : (struct{var algo ; var mode ; var keySize ;
    var opHandle ; var keyHandle}AesCipher ; main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData}),
    running : false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    checkFileExist(fileName(pub(1))), service-out : storageStatus(
    storageNormal), temporary-objects : empty > < keyObj(pub(1)) :
    PersistentObject | trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA,
    object-usage-set : empty, max-object-size : 0 Bits, attribute-set : empty,
    handle-set : none, data-stream-id : streamId(pub(1)), file-id : fileName(
    pub(1)) > < keyObj(pub(2)) : PersistentObject | trust-app-id : REENCRYPT,
    object-type : TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0
    Bits, attribute-set : empty, handle-set : none, data-stream-id : streamId(
    pub(2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2)) (msg anyData from BuildingTemperature to sub(2))) >,
    'check-file-exist} {< mqttzBroker : MqttzBroker | execution-envs : ({< ra :
    RichApp | proc : none, prog : (struct{var algo ; var mode ; var keySize ;
    var opHandle ; var keyHandle}AesCipher ; main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData}),
    running : false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{< ta : TrustApp | trust-app-id : REENCRYPT, app-status : outOfMemory, api-call
    : noCall, api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : REENCRYPT, service-request-ta-inst : ta, service-in :
    nil, service-out : (storageStatus(storageNormal) fileExist),
    temporary-objects : empty > < keyObj(pub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(1)), file-id : fileName(pub(1)) > < keyObj(
    pub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    2)), file-id : fileName(pub(2)) > < keyObj(sub(1)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(1)), file-id : fileName(sub(1)) > < keyObj(
    sub(2)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    2)), file-id : fileName(sub(2)) > < streamId(pub(1)) : DataStreamObject |
    data-size : dataSize(1), content : pos(0) |-> attrContentData(keyAttrValue(
    pub(1))) > < streamId(pub(2)) : DataStreamObject | data-size : dataSize(1),
    content : pos(0) |-> attrContentData(keyAttrValue(pub(2))) > < streamId(
    sub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2)) (msg anyData from BuildingTemperature to sub(2))) >,
    'service-finish}, {< mqttzBroker : MqttzBroker | execution-envs : ({< ra :
    RichApp | proc : none, prog : (struct{var algo ; var mode ; var keySize ;
    var opHandle ; var keyHandle}AesCipher ; main(oriCliId,oriCliData,
    destCliId){var ret ; var sess ; sess := # sessionId(0) ; struct AesCipher
    sessionContext ; sessionContext . algo := # anyAlgo ; sessionContext . mode
    := # anyMode ; sessionContext . keySize := # anyKeySize ; sessionContext .
    opHandle := # TEE-HANDLE-NULL ; sessionContext . keyHandle := #
    TEE-HANDLE-NULL ; var oriCliIv ; oriCliIv := # randomData ; var cmd ; cmd
    := # 3 ; var destCliData ; destCliData := # anyData ; TeecInvokeCommand(
    sess,# main,cmd,sessionContext . algo,sessionContext . mode,sessionContext
    . keySize,sessionContext . opHandle,sessionContext . keyHandle,oriCliId,
    oriCliIv,oriCliData,destCliId,destCliData ; ret) ; return destCliData}),
    running : false, invoke-req-queue : nil, invoke-ret-queue : nil >} |
{retTrustedOS(storageStatus(storageNormal) fileExist, ta) < ta : TrustApp |
    trust-app-id : REENCRYPT, app-status : outOfMemory, api-call : noCall,
    api-return : noReturn, current-api : noApi, api-state : noState,
    current-params : empty, id-counter : 0, proc : none, prog : (struct{var
    objectType ; var objectSize ; var maxObjectSize ; var objectUsage ; var
    dataSize ; var dataPosition ; var handleFlags}TeeObjectInfo ; struct{var
    algo ; var mode ; var keySize ; var opHandle ; var keyHandle}AesCipher ;
    allocResources(session,mode){struct AesCipher sess ; var attr ; var res ;
    sess := session ; sess . algo := # TEE-ALG-AES-CBC-NOPAD ; sess . keySize
    := # 256 Bits ; if(mode === # 1){sess . mode := # TEE-MODE-ENCRYPT}else{if(
    mode === # 0){sess . mode := # TEE-MODE-DECRYPT}else{return #
    TEE-ERROR-BAD-PARAMETERS}} ; if(! sess . opHandle === # TEE-HANDLE-NULL){
    FreeOperation(sess . opHandle ; sess . opHandle)}else{skip} ;
    AllocateOperation(sess . algo,sess . mode,sess . keySize ; res,sess .
    opHandle) ; if(! res === # TEE-SUCCESS){sess . opHandle := #
    TEE-HANDLE-NULL ; goto err}else{skip} ; if(! sess . keyHandle === #
    TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ; sess .
    keyHandle)}else{skip} ; AllocateTransientObject(# TEE-TYPE-AES,sess .
    keySize ; res,sess . keyHandle) ; if(! res === # TEE-SUCCESS){sess .
    keyHandle := # TEE-HANDLE-NULL ; goto err}else{skip} ; InitRefAttribute(#
    TEE-ATTR-SECRET-VALUE,# randomAttrVal ; attr) ; PopulateTransientObject(
    sess . keyHandle,attr ; res) ; if(! res === # TEE-SUCCESS){goto err}else{
    skip} ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res
    === # TEE-SUCCESS){goto err}else{skip} ; return res ; err : if(! sess .
    opHandle === # TEE-HANDLE-NULL){FreeOperation(sess . opHandle ; sess .
    opHandle)}else{skip} ; sess . opHandle := # TEE-HANDLE-NULL ; if(! sess .
    keyHandle === # TEE-HANDLE-NULL){FreeTransientObject(sess . keyHandle ;
    sess . keyHandle)}else{skip} ; sess . keyHandle := # TEE-HANDLE-NULL ;
    return res} ; setAesKey(session,key){struct AesCipher sess ; var attr ; var
    res ; sess := session ; InitRefAttribute(# TEE-ATTR-SECRET-VALUE,key ;
    attr) ; ResetTransientObject(sess . keyHandle ; nil) ;
    PopulateTransientObject(sess . keyHandle,attr ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; ResetOperation(sess . opHandle ; nil)
    ; SetOperationKey(sess . opHandle,sess . keyHandle ; res) ; if(! res === #
    TEE-SUCCESS){return res}else{skip} ; return res} ; setAesIv(session,iv){
    struct AesCipher sess ; sess := session ; CipherInit(sess . opHandle,iv ;
    nil) ; return # TEE-SUCCESS} ; readRawObject(cliId,data){var object ;
    struct TeeObjectInfo objectInfo ; var res ; OpenPersistentObject(#
    TEE-STORAGE-PRIVATE,cliId,# (TEE-DATA-FLAG-ACCESS-READ,
    TEE-DATA-FLAG-SHARE-READ) ; res,object) ; if(! res === # TEE-SUCCESS){
    return res}else{skip} ; GetObjectInfo1(object ; res,objectInfo) ; if(! res
    === # TEE-SUCCESS){goto exit}else{skip} ; ReadObjectData(object,objectInfo
    . dataSize ; res,data) ; if(! res === # TEE-SUCCESS){goto exit}else{skip} ;
    exit : CloseObject(object ; object) ; return res} ; cipherBuffer(sess,
    encData,decData){struct AesCipher session ; session := sess ; if(session .
    opHandle === # TEE-HANDLE-NULL){return # TEE-ERROR-BAD-STATE}else{skip} ;
    var res ; CipherUpdate(session . opHandle,encData ; res,decData) ; return
    res} ; saveKey(cliId,cliKey){var objDataFlag ; var res ; var object ;
    objDataFlag := # (TEE-DATA-FLAG-ACCESS-READ, TEE-DATA-FLAG-ACCESS-WRITE,
    TEE-DATA-FLAG-ACCESS-WRITE-META, TEE-DATA-FLAG-OVERWRITE) ; object := #
    handleId(0, ta) ; CreatePersistentObject(# TEE-STORAGE-PRIVATE,cliId,
    objDataFlag,# TEE-HANDLE-NULL,# (nil).List{Data},# dataSize(0),object ;
    res,object) ; if(! res === # TEE-SUCCESS){return # 1}else{skip} ;
    WriteObjectData(object,cliKey ; res) ; if(! res === # TEE-SUCCESS){
    CloseAndDeletePersistentObject1(object ; res,object) ; return # 1}else{
    skip} ; CloseObject(object ; object) ; return # 0} ; getKey(cliId,cliKey){
    var res ; res := readRawObject(cliId,cliKey) ; if(! res === # TEE-SUCCESS){
    res := saveKey(cliId,cliKey) ; return # 0}else{skip} ; return # 0} ;
    payloadReencryption(session,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){var res ; var oriCliKey ; oriCliKey := # randomAttrVal ; res
    := getKey(oriCliId,oriCliKey) ; if(! res === # 0){res := #
    TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res := allocResources(
    session,# 0) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ;
    goto exit}else{skip} ; res := setAesKey(session,oriCliKey) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    setAesIv(session,oriCliIv) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; var decData ; decData := # (
    nil).List{Data} ; res := cipherBuffer(session,oriCliData,decData) ; if(!
    res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ;
    var destCliIv ; destCliIv := # dummyIv ; var destCliKey ; destCliKey := #
    randomAttrVal ; res := getKey(destCliId,destCliKey) ; if(! res === # 0){res
    := # TEE-ERROR-OUT-OF-MEMORY ; goto exit}else{skip} ; res :=
    allocResources(session,# 1) ; if(! res === # TEE-SUCCESS){res := #
    TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := setAesKey(session,
    destCliKey) ; if(! res === # TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto
    exit}else{skip} ; res := setAesIv(session,destCliIv) ; if(! res === #
    TEE-SUCCESS){res := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res :=
    cipherBuffer(session,decData,destCliData) ; if(! res === # TEE-SUCCESS){res
    := # TEE-ERROR-GENERIC ; goto exit}else{skip} ; res := # TEE-SUCCESS ; goto
    exit ; exit : return res} ; main(command,sessAlgo,sessMode,sessKeySize,
    sessOpHandle,sessKeyHandle,oriCliId,oriCliIv,oriCliData,destCliId,
    destCliData){struct AesCipher session ; session . algo := sessAlgo ;
    session . mode := sessMode ; session . keySize := sessKeySize ; session .
    opHandle := sessOpHandle ; session . keyHandle := sessKeyHandle ; var ret ;
    if(command === # 3){ret := payloadReencryption(session,oriCliId,oriCliIv,
    oriCliData,destCliId,destCliData)}else{ret := # 404} ; return ret}),
    running : false, task : noTask, task-counter : 4 > < osId : TeeOSKernel |
    opened-session : sessionId(0) |-> ta, session-counter : 1, storage :
    REENCRYPT |-> (fileName(pub(1)), fileName(pub(2)), fileName(sub(1)),
    fileName(sub(2))), storage-status : REENCRYPT |-> storageNormal,
    service-request-ta : noAppId, service-request-ta-inst : noInstId,
    service-in : nil, service-out : nil, temporary-objects : empty > < keyObj(
    pub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(pub(
    1)), file-id : fileName(pub(1)) > < keyObj(pub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(pub(2)), file-id : fileName(pub(2)) > < keyObj(
    sub(1)) : PersistentObject | trust-app-id : REENCRYPT, object-type :
    TEE-TYPE-DATA, object-usage-set : empty, max-object-size : 0 Bits,
    attribute-set : empty, handle-set : none, data-stream-id : streamId(sub(
    1)), file-id : fileName(sub(1)) > < keyObj(sub(2)) : PersistentObject |
    trust-app-id : REENCRYPT, object-type : TEE-TYPE-DATA, object-usage-set :
    empty, max-object-size : 0 Bits, attribute-set : empty, handle-set : none,
    data-stream-id : streamId(sub(2)), file-id : fileName(sub(2)) > < streamId(
    pub(1)) : DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(1))) > < streamId(pub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(pub(2))) > < streamId(sub(1)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(1))) > < streamId(sub(2)) :
    DataStreamObject | data-size : dataSize(1), content : pos(0) |->
    attrContentData(keyAttrValue(sub(2))) >}), pub-msg-queue : nil,
    ra-req-queue : nil, ra-ret-queue : nil, cur-ra-req : noRaReq,
    subscriber-list : (ElectricityConsumption |-> sub(1) sub(2),
    BuildingTemperature |-> sub(2)), wait-receiving : false > < pub(1) :
    Publisher | collected-data : nil, data-counter : 1, max-data : 1, topic :
    ElectricityConsumption, sending : false > < pub(2) : Publisher |
    collected-data : nil, data-counter : 2, max-data : 2, topic :
    BuildingTemperature, sending : false > < sub(1) : Subscriber |
    recv-msg-queue : msg anyData from ElectricityConsumption to sub(1) > < sub(
    2) : Subscriber | recv-msg-queue : ((msg anyData from
    ElectricityConsumption to sub(2)) (msg anyData from BuildingTemperature to
    sub(2)) (msg anyData from BuildingTemperature to sub(2))) >,deadlock})
Bye.
